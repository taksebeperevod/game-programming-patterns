Цель

Имитировать независимость объектов в коллекции друг от друга, заставляя их обрабатывать один фрейм поведения за раз.

Причина

Могучая валькирия, управляемая игроком, отправляется похитить великолепные драгоценности из костей давно умершего короля-чародея.

Она осторожно пробирается ко входу в его величественный склеп, и там ее атакуют... а вот и нет.

Ни статуй, поливающих ее молниями.

Ни зомби, патрулирующих вход.

Она просто входит и забирает добычу.

Конец игры.

Вы победили.

Знаете, это никуда не годится.

Кто знает,

может и есть спрос на игры без испытаний.

"10 щелчков мыши для победы!"

может стать следующим хитом продаж.

В склепе должны быть стражники - враги, с которыми наша отважная героиня сможет побороться.

Для начала, мы хотим, чтобы оживший скелет патрулировал по периметру входа.

Отложив все что вы уже скорее всего знаете о программировании игр, вот пример простейшего кода для того, чтобы скелет прогуливался туда-сюда:

Конечно, для короля-чародея мы все-таки хотим получить более изощренное поведение, например он должен уметь оживлять что-нибудь, что имеет намек на мозг.

while (true)

{

// Patrol right.

for (int x = 0; x < 100; x++)

{

skeleton.

x = x;

}

// Patrol left.

for (int x = 100; x > 0; x--)

{

skeleton.

x = x;

}

}

Дело в том, что скелет, конечно, двигается туда и обратно, но игрок этого никогда не увидит.

Программа находится в бесконечном цикле и это совсем не то, что мы хотим.

Нам же нужно, что бы скелет двигался раз за кадр.

Придется убрать эти циклы и положиться на внешний игровой цикл для итерации.

Таким образом игра будет обрабатывать ввод пользователя и рисовать графику, пока охранник нарезает круги.

Like:

Естественно, Game Loop (Цикл игры) это очередной паттерн в этой книге.

Entity skeleton;

bool patrollingLeft = false;

int x = 0;

// Main game loop:

while (true)

{

if (patrollingLeft)

{

x--;

if (x == 0) patrollingLeft = false;

}

else

{

x++;

if (x == 100) patrollingLeft = true;

}

skeleton.

x = x;

// Handle user input and render game...

}

Я показал, что было до и после, что бы было видно как код становится сложнее.

Сначала патрулирование влево и вправо происходило в двух простых циклах

Направление патрулирования хранилось неявно в самих циклах.

Теперь, же каждый кадр приходится возвращаться во внешний игровой цикл, а потом продолжать с того же места. Для этого мы явно храним направление в переменной patrollingLeft.

Раз это более менее работает, то продолжим.

Для того, что бы хорошо встряхнуть норвежскую девицу безмозглого мешка с костями недостаточно, так что теперь мы добавим парочку зачарованных статуй.

Они должны стрелять огненными молниями так часто, что бы держать её на цыпочках.

Если продолжать в духе "самого простого кода", то получится:

// Skeleton variables...

Entity leftStatue;

Entity rightStatue;

int leftStatueFrames = 0;

int rightStatueFrames = 0;

// Main game loop:

while (true)

{

// Skeleton code...

if (++leftStatueFrames == 90)

{

leftStatueFrames = 0;

leftStatue.

shootLightning();

}

if (++rightStatueFrames == 80)

{

rightStatueFrames = 0;

rightStatue.

shootLightning();

}

// Handle user input and render game...

}

Я совершенно уверен, что у вас не возникнет ощущения, что всё это будет легко поддерживать.

Внутри игрового цикла получилось много переменных и императивного кода для каждой сущности игры.

Что бы все они работали одновременно мы смешали их код в пюре.

Если ваш процесс разработки напоминает "пюре", то у вас явно возникла проблема.

Паттерн который используем что бы исправить ситуацию настолько прост, что вы уже наверное сами догадались: каждая сущность в игре должна хранить свое поведение внутри себя.

Таким образом игровой цикл будет лаконичным и можно будет легко добавлять и удалять сущности.

Для этого нам понадобится слой абстракции. Мы добавим его путём определения абстрактного метода update().

Главный игровой цикл (Game loop) обеспечивает функционирование набора объектов, но не знает к какому типу они относятся.

Все что он (Game Loop) знает - это то, что у них есть метод update().

Так мы отделим объекты друг от друга и от игрового цикла.

На каждом фрейме (кадре), главный игровой цикл проходит по коллекции объектов и вызывает для каждого метод update().

И каждый объект выполняет свои действия, которые должны быть выполнены за один фрейм.

Вызов этого метода для каждого объекта на каждом фрейме обеспечивает их одновременные действия.

Конечно, здесь можно придираться к словам и сказать, что все происходит не одновременно.

Пока один объект обновляется, все остальные ждут.

Давайте рассмотрим это подробнее.

Главный игровой цикл содержит коллекцию динамических объектов, так что добавлять и удалять их в уровень также просто как и добавлять и удалять объекты в коллекцию.

И после этого вы можете через, например, какой-нибудь файл с данными, заполнить уровень именно так, как хочет этого наш дизайнер уровней.

The Pattern

Ировой мир обслуживает коллекцию объектов.

Каждый объект имплементирует метод "update", который обновляет состояние для данного фрейма.

Каждый фрейм игра обновляет каждый объект в коллекции.

Когда использовать

If the Game Loop pattern is the best thing since sliced bread, then this pattern is its butter.

Большое количество игр с объектами, которые двигаются и с которыми игроку прходится взаимодействовать так или иначе используют данный паттерн.

Если в игре есть космические пехотинцы, драконы, марсиане, привидения - это прекрасный повод использовать данный паттерн.

Но если в игре движущихся объектов еще меньше, чем движений у игрока и игра больше похожа на шахматы - это не совсем подходящее решение.

В таких играх вам не надо одновременно обновлять состояние всех объектов - возможно, что пешкам нет необходимости каждый кадр изменяться.

Хотя, конечно, и для настольных игр вы, например, захотите добавить анимацию, которую будет необходимо пересчитывать каждый кадр.

Тогда такой паттерн может вам в этом помочь.

Update метод хорошо применим когда

Ваша игра содержит какое-то число объектов или систем, которые необходимо одновременно обсчитывать.

Поведение отдельно взятого объекта слабо зависит от остальных.

Их поведение изменяется во времени.

Помните

Этот способ очень простой и в нем почти нет подводных камней.

Still, every line of code has its ramifications.

Splitting code into single frame slices makes it more complex

When you compare the first two chunks of code, the second is a good bit more complex.

Both simply make the skeleton guard walk back and forth, but the second one does this while yielding control to the game loop each frame.

That change is almost always necessary to handle user input, rendering and the other stuff that the game loop takes care of, so the first example wasn’t very practical.

But it’s worth keeping in mind there’s this sunk complexity cost when you julienne your behavioral code like this.

I say “almost” here because sometimes you can have your cake and eat it too.

You can have straight-line code that never returns for your object behavior, while simultaneously having a number of them running concurrently and coordinating with the game loop.

What you need is a system that lets you have multiple “threads” of execution going on at the same time.

If the code for an object can just pause and resume in the middle of what it’s doing, instead of having to return completely, you can write it in a more imperative form.

Actual threads are usually too heavyweight for this to work well, but if your language supports lightweight concurrency constructs like generators, coroutines, or fibers, you may be able to use those.

The Bytecode pattern is another option that creates threads of execution at the application level.

You have to store state to resume where you left off each frame

In the first code sample, we didn’t have any variables to indicate whether the guard was moving left or right.

That was implicit based on which code was currently executing.

When we changed this to a one-frame-at-a-time form, we had to create a patrollingLeft variable to track that.

When we return out of the code, the execution position is lost so we need to explicitly store enough information to restore it on the next frame.

The State pattern can often help here.

Part of the reason state machines are common in games is because (like their name implies)

they store the kind of state that you need to pick up where you left off.

Objects all simulate each frame but are not truly concurrent

In this pattern, the game loops over a collection of objects and updates each one.

Inside the update() call, most objects are able to reach out and touch the rest of the game world, including other objects that are being updated.

This means that the order that the objects are updated is significant.

If A comes before B in the list of objects, then when A updates, it will see B’s previous state.

But when B updates, it will see A’s new state, since it’s already updated this frame.

Even though from the player’s perspective everything is moving at the “same” time, the core of the game is still turn-based.

It’s just that a complete turn is only one frame long.

If, for some reason, you decide you don’t want your game to be sequential like this, you would need to use something like the Double Buffer pattern.

That makes the order that A and B update not matter because both of them will see the previous frame’s state.

This is mostly a good thing as far as the game logic is concerned.

Updating objects in parallel leads you to some unpleasant semantic corners.

Imagine a game of chess where black and white moved at the same time.

They both try to make a move that places a piece in the same currently empty square.

How should this be resolved?

Updating sequentially solves this: each update incrementally changes the world from one valid state to the next with no period of time where things are ambiguous and need to be reconciled.

It may also help multiplayer since you have a serialized set of moves that can be sent over the network.

Be careful modifying the object list while updating

When you’re using this pattern, a lot of the game’s behavior ends up nestled in these update methods.

That often includes code that adds or removes updatable objects from the game.

For example, say a skeleton guard drops an item when slain.

With a new object, you can usually just add it to the end of the list without too much trouble.

You’ll keep iterating over that list and eventually get to the new one at the end and update it too.

But that does mean that the new object gets a chance to act during the frame that it was spawned, before the player has had a chance to even see it.

If you don’t want that to happen, one simple fix is to cache the number of objects in the list at the beginning of the update loop and only update that many before stopping:

int numObjectsThisTurn = numObjects;

for (int i = 0; i < numObjectsThisTurn; i++)

{

objects[i]->update();

}

Here, objects is an array of the updatable objects in the game, and numObjects is its length.

When new objects are added, it gets incremented.

We cache the length in numObjectsThisTurn at the beginning of the loop so that the iteration stops before we get to any new objects added during the current frame.

A hairier problem is when objects are removed while iterating.

You vanquish some foul beast and now it needs to get yanked out of the object list.

If it happens to be before the current object you’re updating in the list, you can accidentally skip an object:

for (int i = 0; i < numObjects; i++)

{

objects[i]->update();

}

This simple loop increments the index of the object being updated each iteration.

The left side of the illustration below shows what the array looks like while we’re updating the heroine:

Since we’re updating her, i is 1. She slays the foul beast so it gets removed from the array.

The heroine shifts up to 0, and the hapless peasant shifts up to 1. After updating the heroine, i is incremented to 2. As you can see on the right, the hapless peasant is skipped over and never gets updated.

One fix is to just be careful when you remove objects and update any iteration variables to take the removal into account.

Another is to defer removals until you’re done walking the list.

Mark the object as “dead” but leave it in place.

During updating, make sure to skip any dead objects.

Then, when that’s done, walk the list again to remove the corpses.

You could also walk the list backwards when you update.

That way removing an item doesn’t shift any of the items yet to be updated.

If you have multiple threads processing the items in the update loop, then you are even more likely to defer any modification to it to avoid costly thread synchronization during updates.

Sample Code

This pattern is so straightforward the sample code almost belabors the point.

That doesn’t mean the pattern isn’t useful.

It’s useful in part because it’s simple: it’s a clean solution to a problem without a lot of ornamentation.

But just to keep things concrete, let’s walk through a basic implementation.

We’ll start with an entity class that will represent the skeletons and statues:

class Entity

{

public:

Entity()

: x(0), y(0)

{}

virtual ~Entity() {}

virtual void update() = 0;

protected:

double x;

double y;

};

I stuck a few things in there, but just the bare minimum we’ll need later.

Presumably in real code there’d be lots of other stuff like graphics and physics.

The important bit for this pattern is that it has a virtual update() method.

The game maintains a collection of these entities.

In our sample, we’ll put that in a class representing the game world:

class World

{

public:

World()

: numEntities_(0)

{}

void gameLoop();

private:

Entity* entities_[MAX_ENTITIES];

int numEntities_;

};

In a real-world program, you’d probably use an actual collection class, but I’m just using a vanilla array here to keep things simple.

Now that everything is set up, the game implements the pattern by updating each entity every frame:

void World::gameLoop()

{

while (true)

{

// Handle user input...

// Update each entity.

for (int i = 0; i < numEntities_; i++)

{

entities_[i]->update();

}

// Physics and rendering...

}

}

As the name of the method implies, this is an example of the Game Loop pattern.

Subclassing entities?!

There are some readers whose skin is crawling right now because I’m using inheritance on the main entity class to define different behaviors.

If you don’t happen to see the problem, I’ll provide some context.

When the game industry emerged from the primordial seas of 6502 assembly code and VBLANKs onto the shores of object-oriented languages, developers went into a software architecture fad frenzy.

One of the biggest was using inheritance.

Towering, Byzantine class hierarchies were built, big enough to blot out the sun.

It turns out that was a terrible idea and no one can maintain giant class hierarchies without it crumbling around them.

Even the Gang of Four knew this in 1994 when they wrote:

Favor ‘object composition’ over ‘class inheritance’.

Just between you and me, I think the pendulum has swung a bit too far away from subclassing.

I generally avoid it, but being dogmatic about not using inheritance is as bad as being dogmatic about using it.

You can use it in moderation without having to be a teetotaler.

When this realization percolated through the game industry, the solution that emerged was the Component pattern.

Using that, update() would be on the component types instead of Entity.

That lets you avoid creating complicated class hierarchies of entities to define and reuse behavior.

Instead, you just mix and match components.

If I were making a real game, I’d probably do that too.

But this chapter isn’t about components.

It’s about update() methods, and the simplest way I can show them, with as few moving parts as possible, is by putting that method right on Entity and making a few subclasses.

This one is.

Defining entities

OK, back to the task at hand.

Our original motivation was to be able to define a patrolling skeleton guard and some lightning-bolt-unleashing magical statues.

Let’s start with our bony friend.

To define his patrolling behavior, we make a new entity that implements update() appropriately:

class Skeleton : public Entity

{

public:

Skeleton()

: patrollingLeft_(false)

{}

virtual void update()

{

if (patrollingLeft_)

{

x--;

if (x == 0) patrollingLeft_ = false;

}

else

{

x++;

if (x == 100) patrollingLeft_ = true;

}

}

private:

bool patrollingLeft_;

};

As you can see, we pretty much just cut that chunk of code from the game loop earlier in the chapter and pasted it into Skeleton‘s update() method.

The one minor difference is that patrollingLeft_ has been made into a field instead of a local variable.

That way its value sticks around between calls to update().

Let’s do this again with the statue:

class Statue : public Entity

{

public:

Statue(int delay)

: frames_(0),

delay_(delay)

{}

virtual void update()

{

if (++frames_ == delay_)

{

shootLightning();

// Reset the timer.

frames_ = 0;

}

}

private:

int frames_;

int delay_;

void shootLightning()

{

// Shoot the lightning...

}

};

Again, most of the change is just moving code out of the game loop and into the class and renaming some stuff.

In this case, though, we’ve actually made the codebase simpler.

In the original nasty imperative code, there were separate local variables for each statue’s frame counter and rate of fire.

Do people still care about UML?

If so, here’s what we just created.

Now that those have been moved into the Statue class itself, you can create as many as you want and each instance will have its own little timer.

That’s really the motivation behind this pattern: it’s now much easier to add new entities to the game world because each one brings along everything it needs to take care of itself.

This pattern lets us separate populating the game world from implementing it.

This in turn gives us the flexibility to populate the world using something like a separate data file or level editor.

Passing time

That’s key pattern, but I’ll just touch on a common refinement.

So far, we’ve assumed every call to update() advances the state of the game world by the same fixed unit of time.

I happen to prefer that, but many games use a variable time step.

In those, each turn of the game loop may simulate a larger or smaller slice of time depending on how long it took to process and render the previous frame.

The Game Loop chapter has a lot more on the advantages and disadvantages of fixed and variable time steps.

That means that each update() call needs to know how far the hand of the virtual clock has swung, so you’ll often see the elapsed time passed in.

For example, we can make our patrolling skeleton handle a variable time step like so:

void Skeleton::update(double elapsed)

{

if (patrollingLeft_)

{

x -= elapsed;

if (x <= 0)

{

patrollingLeft_ = false;

x = -x;

}

}

else

{

x += elapsed;

if (x >= 100) {

patrollingLeft_ = true;

x = 100 - (x - 100);

}

}

}

Now, the distance the skeleton moves increases as the elapsed time grows.

You can also see the additional complexity of dealing with a variable time step.

The skeleton may overshoot the bounds of its patrol with a large time slice and we have to carefully handle that.

Design Decisions

With a simple pattern like this, there isn’t too much variation, but there’s still a couple of knobs you can turn.

What class does the update method live on?

The most obvious and most important decision you’ll make is what class to put update() on.

The entity class.

This is the simplest option if you already have an entity class since it doesn’t bring any additional classes into play.

This may work if you don’t have too many kinds of entities, but the industry is generally moving away from this.

Having to subclass Entity every time you want a new behavior is brittle and painful when you have a large number of different kinds.

You’ll eventually find yourself wanting to reuse pieces of code in a way that doesn’t gracefully map to a single inheritance hierarchy and then you’re stuck.

The component class.

If you’re already using the Component pattern, this is a no-brainer.

It lets each component update itself independently.

In the same way that the update pattern in general lets you decouple game entities from each other in the game world, this lets you decouple parts of a single entity from each other.

Rendering, physics, and AI can all take care of themselves.

A delegate class.

There are other patterns that involve delegating part of a class’s behavior to another object.

The State pattern does this so that you can change an object’s behavior by changing what it delegates to.

The Type Object pattern does this so that you can share behavior across a bunch of entities of the same “kind”.

If you’re using one of those patterns, it’s natural to put update() on that delegated class.

In that case, you may still have the update() method on the main class, but it will be non-virtual and just forward to the delegate object.

Something like:

void Entity::update()

{

// Forward to state object.

state_->update();

}

Doing this lets you define new behavior by changing out the delegated object.

Like using components, it gives you the flexibility to change behavior without having to define an entirely new subclass.

How are dormant objects handled?

You often have a number of objects in the world that for whatever reason temporarily don’t need to be updated.

They could be disabled, or off-screen, or not unlocked yet.

If a large number of objects are in this state, it can be a waste of CPU cycles to walk over them each frame only to do nothing.

One alternative is to maintain a separate collection of just the “live” objects that do need updating.

When an object is disabled, it’s removed from the collection.

When it gets re-enabled, it’s added back.

This way, you only iterate over items that actually have real work do to.

If you use a single collection containing inactive objects:

You waste time.

For inactive objects, you’ll end up either checking some “am I enabled” flag or calling a method that does nothing.

In addition to wasted CPU cycles checking if the object is enabled and skipping past it, pointlessly iterating over objects can blow your data cache.

CPUs optimize reads by loading memory from RAM into much faster on-chip caches.

They do this speculatively by assuming you’re likely to read memory right after a location you just read.

When you skip over an object, you can skip past the end of the cache, forcing it to go and slowly pull in another chunk of main memory.

If you use a separate collection of only active objects:

You use extra memory to maintain the second collection.

There’s still usually another master collection of all entities for cases where you need them all.

In that case, this collection is technically redundant.

When speed is tighter than memory (which it often is)

, this can still be a worthwhile trade-off.

Another option to mitigate this is to have two collections, but have the other collection only contain the inactive entities instead of all of them.

You have to keep the collections in sync.

When objects are created or completely destroyed (and not just made temporarily inactive)

, you have to remember to modify both the master collection and this one.

The metric that should guide your approach here is how many inactive objects you tend to have.

The more you have, the more useful it is to have a separate collection that avoids them during your core game loop.

See Also

This pattern is part of a trinity with Game Loop and Component that often form the nucleus of a game engine.

When you start caring about the cache performance of updating a bunch of entities or components in a loop each frame, the Data Locality pattern can help make that faster.

The Unity framework uses this pattern in several classes, including MonoBehaviour.

Microsoft’s XNA platform uses this pattern both in the Game and GameComponent classes.

The Quintus JavaScript game engine uses this pattern on its main Sprite class.

Переведено на Нотабеноиде
http://notabenoid.com/book/51192/215219

Переводчики: MrSmith33, fregate, Deo, Vladislav86

