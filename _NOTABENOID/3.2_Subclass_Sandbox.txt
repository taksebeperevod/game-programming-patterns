Цель

Создание различных видов поведения путём определения подклассов, которые используют операции, предоставляемые их общим базовым классом.

Мотивация

Каждый ребёнок мечтал стать супергероем, но, к сожалению, здесь, на Земле, недостаёт космических лучей.

Игры, позволяющие нам стать супергероем, являются наиболее близким приближением.

Поскольку наши игровые дизайнеры никогда не научатся говорить «нет», у нашего супергероя в игре планируются десятки, если не сотни, различных суперспособностей, которые могут заиметь игроки.

Наш план состоит в том, что мы будем иметь базовый класс суперспособности Superpower.

Затем мы создадим производные классы для каждой суперспособности.

Мы поделим дизайн-документ между нашей командой программистов и поручим им писать код.

Когда всё будет готово, мы будем иметь сотню классов суперспособностей.

Когда вы столкнётесь с большим количеством подклассов, как в этом примере, часто это будет значить, что подход, основанный на управлении данными, будет лучшим.

Вместо того, чтобы писать большое количество кода, определяющего различные способности, попробуйте найти способ определения их поведения через данные.

Шаблоны Объект типа, Байт-код и Интерпретатор — все они могут помочь.

Мы хотим, чтобы наш игрок погрузился в мир, изобилующий разнообразием.

О какой бы способности мы не мечтали, будучи ребёнком, мы хотим видеть её в игре.

Это означает, что подклассам суперспособностей необходимо делать практически всё: проигрывать звуки, порождать визуальные эффекты, взаимодействовать с ИИ, создавать и разрушать другие сущности игры и заморачиваться с физикой.

Не будет такого уголка в кодовой базе, который не был бы затронут этими подклассами.

Давайте предположим, что мы просто развязали руки нашей команде и поручили им написать классы суперспособностей.

Что произойдёт?

Появится много избыточного кода.

Хотя разные способности будут дико разнообразны, мы всё ещё можем ожидать значительного перекрытия функционала.

Многие из них будут порождать визуальные эффекты и проигрывать звуки одинаковым способом.

Замораживающий луч, тепловой луч и горчичный луч — все они довольно похожи, когда вы берётесь за них.

Если не координировать людей, реализующих их, будет много повторяющегося кода и впустую потраченных усилий.

Каждая часть игрового движка будет связана с этими классами.

Не зная ничего лучше, люди будут писать код, вызываемый из подсистем, которые никогда не были привязаны непосредственно к классам суперспособностей.

Если ваша система отрисовки организована несколькими аккуратными слоями, только один из которых предназначен для использования кодом вне графического движка, мы можем поспорить, что код суперспособностей проникнет в каждый из них.

Когда эти внешние системы необходимо будет изменить, появится неплохой шанс сломать код суперспособностей.

Как только мы заимеем различные классы суперспособностей, связанные между собой и различными частями игрового движка, неизбежно изменения в этих системах повлияют на классы способностей.

Это грустно, поскольку ваши программисты графики звука и пользовательского интерфейса вряд ли захотят так же быть программистами игрового процесса. 

Будет трудно определить, каким инвариантам следуют все суперспособности.

Скажем, мы хотим быть уверенными в том, что все звуки, проигрываемые нашими способностями, правильно расставлены в очередь и приоретизированы.

У нас нет простого способа убедиться в этом, если все сто наших классов самостоятельно напрямую вызывают звуковой движок.

Что мы хотим — так это дать каждому программисту игрового процесса, реализующему суперспособность, набор «игрушек», с которым он мог бы играться.

Вы хотите, чтобы ваша способность проиграла звук — вот вам функция playSound().

Хотите частиц?

Вот spawnParticles(). Мы обеспечим, чтобы эти операции покрыли все ваши нужды, так что вам не нужно будет включать случайные заголовочные файлы и совать свой нос в остальные части кодовой базы.

Мы сделаем это, сделав операции защищёнными методами в базовом классе Superpower.

Поместив их в базовый класс, мы дадим каждому подклассу способности прямой и простой доступ к ним.

Сделав их защищёнными (и, вероятно, невиртуальными),

 мы тем самым сообщим, что они существуют специально для вызова из подклассов.

Как только у вас появятся эти игрушки, с которыми можно поиграть, нужно будет найти место их применения.

Для этого мы определим метод песочницы: абстрактный защищённый метод, которые подклассы должны будут реализовать.

С учётом всего вышесказанного, для реализации нового вида способности вам будет необходимо:

Создать подкласс класса Superpower.

Переопределить метод activate().

Реализовать тело метода, вызывая защищённые методы, предоставляемые классом Superpower.

Теперь мы можем поправить нашу проблему избыточного кода путём предоставления таких высокоуровневых операций, какие только возможно предоставить.

Когда мы видим код, дублирующийся во множестве подклассов, мы всегда можем выделить его в новую операцию в классе Superpower и далее использовать её.

Мы обратили нашу проблему связности путём помещения этой связности в одно место.

Сами суперспособности в конечном итоге, привязаны к различным игровым системам, но наши сто производных классов — нет.

Вместо этого, они связаны только с их базовым классом.

Когда изменится одна из этих игровых систем, может понадобиться изменить и класс Superpower, но не десятки его подклассов.

Этот шаблон подводит к архитектуре, где вы имеете не глубокую, но широкую иерархию классов.

Ваши цепочки наследования не глубокие, но есть множество классов, свисающих с Superpower.

Имея один класс с множеством прямых подклассов, мы имеем точку опоры в нашей кодовой базе.

Время и любовь, которые мы вкладываем в класс Superpower, могут принести выгоду широкому набору классов в игре.

В последнее время вы обнаружите множество людей, критикующих наследование в объектно-ориентированных языках.

Наследование здесь сомнительно — связей в кодовой базе глубже одной, между базовым классом и его подклассами, нет — но я обнаружил, что с широкими деревьями наследования работа проще, чем с глубокими.

Шаблон

Базовый класс определяет абстрактный метод песочницы и предоставляет несколько операций.

Пометка их как защищённых, даёт понять, что они нужны для использования в производных классах.

Каждый производный подкласс песочницы реализует метод песочницы, используя предоставленные операции.

Когда использовать

Этот очень простой, общий шаблон скрывается во множестве кодовых баз, даже за пределами игр.

Если у вас кругом лежат невиртуальные защищённые методы, вполне возможно, что вы уже используете нечто подобное.

Подкласс песочницы хорошо подходит, если:

Вы имеете базовый класс с рядом производных классов.

Базовый класс в состоянии предоставить все операции, которые могут понадобиться производному классу.

В подклассах есть перекрывающееся поведение и вы хотите упростить разделение кода между ними.

Вы хотите минимизировать связность между этими производными классами и остальной частью программы.

Имейте в виду

Он может сделать базовый класс чрезмерно тяжёлым.

Поскольку каждая зависимость, которую используют подклассы, проходит сначала через базовый класс, в конечном итоге он окажется очень сильно связан с остальной частью игры.

Also, the subclasses themselves are deeply tied to the base class.

Those together mean that making changes to it can be difficult without breaking something — you’ve got the brittle base class problem.

If you find this pattern is turning your base class into a giant bowl of code stew, consider pulling some of the provided operations out into separate classes that the base class can dole out responsibility to.

The Component pattern can help here.

Derived classes are only coupled to their base class

The flip side of the coin is that since most of your coupling has been pushed up to the base class, the derived classes are now much more cleanly separated.

Ideally, most of the total volume of your game code will be in those subclasses.

That means much of your codebase is isolated and fairly easy to maintain.

Sample Code

Because this is such a simple pattern, there isn’t much to the sample code.

That doesn’t mean it isn’t useful — the pattern is about the intent, and not the complexity of its implementation.

We’ll start with our Superpower base class:

class Superpower

{

public:

virtual ~Superpower() {}

protected:

virtual void activate() = 0;

void move(double x, double y, double z)

{

// Code here...

}

void playSound(SoundId sound, double volume)

{

// Code here...

}

void spawnParticles(ParticleType type, int count)

{

// Code here...

}

};

The activate() method is the sandbox method.

Since it is virtual and abstract, subclasses must override it.

This makes it clear to someone creating a power class where their work has to go.

The other protected methods, move(), playSound(), and spawnParticles() are the provided operations.

These are what the subclasses will call in their implementation of activate().

We didn’t implement the provided operations in this example, but an actual game would have real code there.

Those methods are where Superpower gets coupled to other systems in the game: move() may call into physics code, playSound() will talk to the audio engine, etc.

Since this is all in the implementation of the base class, it keeps that coupling encapsulated within Superpower itself.

OK, now let’s get our radioactive spiders out and create a power.

Here’s one:

class SkyLaunch : public Superpower

{

protected:

virtual void activate()

{

// Spring into the air.

playSound(SOUND_SPROING, 1.0f)

;

spawnParticles(PARTICLE_DUST, 10);

move(0, 0, 20);

}

};

OK, maybe being able to jump isn’t all that super, but I’m trying to keep things basic here.

This power springs the superhero into the air, playing an appropriate sound and kicking up a little cloud of dust.

If all of the superpowers were this simple — just combination of a sound, particle affect, and motion — then we wouldn’t need this pattern at all.

Instead, Superpower could just have a baked-in implementation of activate() that accesses fields for the sound ID, particle type, and movement.

But that only works when every power essentially works the same way with just some differences in data.

Let’s elaborate it a bit.

class Superpower

{

protected:

double getHeroX()

{

// Code here...

}

double getHeroY()

{

// Code here...

}

double getHeroZ()

{

// Code here...

}

// Existing stuff...

};

Here, we’ve added a couple of methods to get the hero’s position.

Our SkyLaunch subclass can now use those:

class SkyLaunch : public Superpower

{

protected:

virtual void activate()

{

if (getHeroZ() == 0)

{

// On the ground, so spring into the air.

playSound(SOUND_SPROING, 1.0f)

;

spawnParticles(PARTICLE_DUST, 10);

move(0, 0, 20);

}

else if (getHeroZ() < 10.0f)

{

// Near the ground, so do a double jump.

playSound(SOUND_SWOOP, 1.0f)

;

move(0, 0, getHeroZ() - 20);

}

else

{

// Way up in the air, so do a dive attack.

playSound(SOUND_DIVE, 0.7f)

;

spawnParticles(PARTICLE_SPARKLES, 1);

move(0, 0, -getHeroZ());

}

}

};

Since we have access to some state, now our sandbox method can do actual interesting control flow.

Here it’s still just a couple of simple if statements, but you can do anything you want.

By having the sandbox method be an actual full-fledged method that contains arbitrary code, the sky’s the limit.

Earlier I suggested a data-driven approach for powers.

This is one reason why you may decide to not do that.

If your behavior is complex and imperative, that makes it more difficult to define in data.

Design Decisions

As you can see, this is a fairly “soft” pattern.

It describes a basic idea, but doesn’t have a lot of detailed mechanics.

That means you’ll be making some interesting choices each time you apply it.

Here are some questions to consider.

What operations should be provided?

This is the biggest question.

It deeply affects how this pattern feels and how well it works.

At the minimum end of the spectrum, the base class doesn’t provide any operations.

It just has a sandbox method.

To implement it, you’ll have to call into systems outside of the base class.

If you take that angle, it’s probably not even fair to say you’re using this pattern.

On the other end of the spectrum, the base class provides every operation that a subclass may need.

Subclasses are only coupled to the base class and don’t call into any outside systems whatsoever.

Concretely, this means each source file for a subclass would only need a single #include: the one for its base class.

Between these two points, there’s a wide middle ground where some operations are provided by the base class and others are accessed directly from the outside system that defines it.

The more operations you provide, the less coupled subclasses are to outside systems, but the more coupled the base class is.

It removes coupling from the derived classes, but only by pushing that up to the base class itself.

That’s a win if you have a bunch of derived classes that were all coupled to some outside system.

By moving that up into a provided operation, you’ve centralized that coupling into one place: the base class.

But the more you do this, the bigger and harder to maintain that one class becomes.

So where to draw the line?

Here’s a few rules of thumb:

If a provided operation is only used by one or a few subclasses, you don’t get a lot of bang for your buck.

You’re adding complexity to the base class, which affects everyone, but only a couple of classes benefit.

This may be worth it for making the operation consistent with other provided operations, or it may be simpler and cleaner just to let those special case subclasses call out to the external systems directly.

When you call a method in some other corner of the game, it’s less intrusive if that method doesn’t modify any state.

It still creates a coupling, but it’s a “safe” coupling because it can’t break anything in the game.

“Safe” is in quotes here because technically even just accessing data can cause problems.

If your game is multi-threaded, you could read something at the same time that it’s being modified.

If you aren’t careful you can end up with bogus data.

Another nasty case is if your game state is strictly deterministic (which many online games are in order to keep players in sync).

If you access something outside of the set of synchronized game state, you can cause incredibly painful non-determinism bugs.

Calls that do modify state, on the other hand, more deeply tie you to those parts of the codebase, and you need to be much more cognizant of that.

That makes them good candidates for being rolled up into provided operations in the more visible base class.

If the implementation of a provided operation just forwards a call to some outside system, then it isn’t adding much value.

In that case, it may be simpler to just call the outside method directly.

However, even simple forwarding can still be useful: those methods often access state that the base class doesn’t want to directly expose to subclasses.

For example, let’s say Superpower provided this:

void playSound(SoundId sound, double volume)

{

soundEngine_.play(sound, volume)

;

}

It’s just forwarding the call to some soundEngine_ field in Superpower.

The advantage, though, is that it keeps that field encapsulated in Superpower so subclasses can’t poke at it.

Should methods be provided directly, or through objects that contain them?

The challenge with this pattern is that you can end up with a painfully large number of methods crammed into your base class.

You can mitigate that by moving some of those methods over to other classes.

The provided operations in the base class then just return one of those objects.

For example, to let a power play sounds, we could add these directly to Superpower:

class Superpower

{

protected:

void playSound(SoundId sound, double volume)

{

// Code here...

}

void stopSound(SoundId sound)

{

// Code here...

}

void setVolume(SoundId sound)

{

// Code here...

}

// Sandbox method and other operations...

};

But if Superpower is already getting large and unwieldy, we might want to avoid that.

Instead, we create a SoundPlayer class that exposes that functionality:

class SoundPlayer

{

void playSound(SoundId sound, double volume)

{

// Code here...

}

void stopSound(SoundId sound)

{

// Code here...

}

void setVolume(SoundId sound)

{

// Code here...

}

};

Then Superpower just provides access to it:

class Superpower

{

protected:

SoundPlayer& getSoundPlayer()

{

return soundPlayer_;

}

// Sandbox method and other operations...

private:

SoundPlayer soundPlayer_;

};

Shunting provided operations into auxilliary classes like this can do a few things for you:

It reduces the number of methods in the base class.

In the example here, we went from three methods to just a single getter.

Code in the helper class is usually easier to maintain.

Core base classes like Superpower, despite our best intentions, tend to be tricky to change since so much depends on them.

By moving functionality over to a less coupled secondary class, we make that code easier to poke at without breaking things.

It lowers the coupling between the base class and other systems.

When playSound() was a method directly on Superpower, that meant our base class was directly tied to SoundId and whatever audio code the implementation called into.

Moving that over to SoundPlayer reduces Superpower‘s coupling to just that single SoundPlayer class, which then encapsulates all of its other dependencies.

How does the base class get the state that it needs?

Your base class will often need some data that it wants to encapsulate and keep hidden from its subclasses.

In our first example, the Superpower class provided a spawnParticles() method.

If the implementation of that needs some particle system object, how would it get one?

Pass it to the base class constructor.

The simplest solution is to have the base class take it as a constructor argument:

class Superpower

{

public:

Superpower(ParticleSystem* particles)

: particles_(particles)

{}

// Sandbox method and other operations...

private:

ParticleSystem* particles_;

};

This safely ensures that every superpower does have a particle system by the time it’s constructed.

But let’s look at a derived class:

class SkyLaunch : public Superpower

{

public:

SkyLaunch(ParticleSystem* particles)

: Superpower(particles)

{}

};

Here we see the problem.

Every derived class will need to have a constructor that calls the base class one and passes along that argument.

That exposes every derived class to a piece of state that we don’t want them to know about.

This is also a maintenance headache.

If we later add another piece of state to the base class, every constructor in each of our derived classes will have to be modified to pass it along.

Do two-stage initialization.

To avoid passing everything through the constructor, we can split initialization into two steps.

The constructor will take no parameters and just create the object.

Then we call a separate method defined directly on the base class to pass in the rest of the data that it needs.

Superpower* power = new SkyLaunch();

power->init(particles)

;

Note here that since we aren’t passing anything into the constructor for SkyLaunch, it isn’t coupled to anything we want to keep private in Superpower.

The trouble with this approach, though, is that you have to make sure you always remember to call init(). If you ever forget, you’ll have a power that’s in some twilight half-created state and won’t work.

You can fix that by encapsulating the entire process into a single function, like so:

Superpower* createSkyLaunch(ParticleSystem* particles)

{

Superpower* power = new SkyLaunch();

power->init(particles)

;

return power;

}

With a little trickery like private constructors and friend classes, you can ensure this createSkylaunch() function is the only function that can actually create powers.

That way, you can’t forget any of the initialization stages.

Make the state static.

In the previous example, we were initializing each Superpower instance with a particle system.

That makes sense when every power needs its own unique state.

But let’s say that the particle system is a Singleton, and every power will be sharing the same one.

In that case, we can make the state private to the base class, but also make it static.

The game will still have to make sure that it initializes the state, but it only has to initialize the Superpower class once for the entire game, and not each instance.

Keep in mind that this still has many of the problems of a singleton: you’ve got some state shared between lots and lots of objects (all of the Superpower instances).

The particle system is encapsulated, so it isn’t globally visible which is good, but it can still make reasoning about powers harder because they can all poke at the same object.

class Superpower

{

public:

static void init(ParticleSystem* particles)

{

particles_ = particles;

}

// Sandbox method and other operations...

private:

static ParticleSystem* particles_;

};

Note here that init() and particles_ are both static.

As long as the game calls Superpower::init() once early on, every power can access the particle system.

At the same time, Superpower instances can be created freely just by calling the right derived class’s constructor.

Even better, now that particles_ is a static variable, we don’t have to store it for each instance of Superpower, so we’ve made the class use less memory.

Use a service locator.

The previous option requires that outside code specifically remember to push in the state that the base class needs before it needs it.

That places the burden of initialization on the surrounding code.

Another option is to let the base class handle it by pulling in the state it needs.

One way to do that is by using a Service Locator.

class Superpower

{

protected:

void spawnParticles(ParticleType type, int count)

{

ParticleSystem& particles = ServiceLocator::getParticles();

particles.

spawn(type, count)

;

}

// Sandbox method and other operations...

};

Here, spawnParticles() needs a particle system.

Instead of being given one by outside code, it just fetches one itself from the service locator.

See Also

When you apply the Update Method pattern, your update method will very often also be a sandbox method.

The Template Method Pattern pattern is basically the inverse of this.

In that pattern, the base class defines a single high-level method that it implements by calling primitive operations.

These primitive operations are abstract and get implemented by the subclasses.

So where the Subclass Sandbox pattern provides the primitives and delegates the high-level behavior to subclasses, the Template Method Pattern provides the high-level behavior and delegates the primitives.

Переведено на Нотабеноиде
http://notabenoid.com/book/51192/215223

Переводчики: Mingun, XDMaik

