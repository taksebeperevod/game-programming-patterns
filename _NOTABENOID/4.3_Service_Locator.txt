Цель

Обеспечить глобальную точку доступа к службе без привязки пользователей к конкретному классу, который это реализует.

Причина

Некоторые объекты или системы игры используются практически в каждом уголке нашего кода.

Достаточно трудно найти ту часть игры, которая не нуждается в распределении памяти, логировании, файловой системе или случайных числах.

Такие системы можно рассматривать как службы, которые должны быть доступны всей игре.

К примеру, возьмем аудио.

Конечно, тут нет настолько низкоуровневых вещей, как в распределении памяти, но тем не менее аудио затрагивает большое количество игровых систем: падение камня на землю должно сопровождаться грохотом (физика).

Снайпер стреляет из своего оружия и раздается звук выстрела (ИИ).

Выбор пользователем пункта меню сопровождается звуковым сигналом подтверждения (пользовательский интерфейс).

Каждая из перечисленных частей игры должна уметь вызывать аудио подсистему, приблизительно такими способами:

// Использовать статический класс?

AudioSystem::playSound(VERY_LOUD_BANG)

;

// А может Singleton?

AudioSystem::instance()->playSound(VERY_LOUD_BANG)

;

Каждый способ приводит к цели, но по пути мы намертво к нему привязваемся.

Каждое место в игре вызывая нашу аудио подсистему напрямую ссылается на конкретный класс AudioSystem и механизм доступа к нему - либо через статический класс, либо через синглтон.

Конечно, чтобы воспроизводить звуки, эти вызовы должны быть привязаны  к чему-либо, но позволяя им напрямую тыкать в конкретную аудио реализацию - это как дать сотне незнакомцев ваш адрес, только  чтобы они забросили письмо к вам на порог.

Кроме того, что это слишком личное, при переезде вы получите головную боль, обьясняя всем новый маршрут.

Есть решение получше: телефонная книга.

Люди, которые хотят с нами связаться, могут найти нас по имени и получить наш текущий адрес.

При переезде мы уведомляем об этом телефонную компанию.

Они обновляют книгу, и все получают новый адрес.

Вообще-то, мы даже совсем не обязаны предоставлять свой реальный адрес.

We can list a P.

O.

box or some other “representation” of ourselves instead.

Заставляя вызывающую сторону заглянуть в телефонную книгу, чтобы нас найти, мы получаем удобное единственное место, где контролируем как нас найти.

Так работает паттерн Service Locator: он отделяет код, которому требуется служба, и от того что это за служба (от конкретной реализации типа),

и от того, где она расположена (как мы получаем ее экземпляр).

The Pattern

Класс службы определяет абстрактный интерфейс к набору операций.

Конкретный поставщик службы реализует этот интерфейс.

Отдельно взятый Service Locator предоставляет доступ к службе, отыскивая подходящего поставщика, в то же время скрывая как его конкретный тип, так и алгоритм поиска.

Когда использовать

Каждый раз, когда делаете что-нибудь доступным всем частям вашей программы, вы ищите неприятностей.

Это основная проблема паттерна Singleton, и этот паттерн не исключение.

Мой простейший совет о том, как использовать Service Locator - используйте экономно.

Вместо использования глобального механизма для предоставления некоторому коду доступа к нужному ему объекту, сперва рассмотрите возможность просто передать объект ему.

Просто как 5 копеек, и делает связывание очевидным.

Охватывает большую часть ваших ситуаций.

Но...бывают случаи, когда передача объекта "вручную" неуместна, или сильно "засоряет" код.

Некоторые подсистемы, такие как логирование и управление памятью, не должны быть частью открытого API.

А параметры в коде, отвечающем за рендеринг должны относиться к рендерингу, а не к таким штукам как логирование.

Likewise, other systems represent facilities that are fundamentally singular in nature.

Ваша игра, скорее всего, взаимодействует лишь с одним аудио устройством или видео системой.

Это естественное свойство среды, поэтому проводить его через 10 слоев методов , только чтобы один глубоко вложенный метод мог его вызвать, значит добавлять ненужную сложность в ваш код.

В таких случаях, этот паттерн может помочь.

As we’ll see, it functions as a more flexible, more configurable cousin of the singleton.

When used well, it can make your codebase more flexible with little runtime cost.

Keep in Mind

The core difficulty with a service locator is that it takes a dependency — a bit of coupling between two pieces of code — and defers wiring it up until runtime.

This gives you flexibility, but the price you pay is that it’s harder to understand what your dependencies are just by reading the code.

The service actually has to be located

With a singleton or a static class, there’s no chance for the instance we need to not be available.

Calling code can take for granted that it’s there.

But since this pattern has to locate the service, we may need to handle cases where that fails.

Fortunately, we’ll cover a strategy later to address this and guarantee that we’ll always get some service when you need it.

The service doesn’t know who is locating it

Since the locator is globally accessible, any code in the game could be requesting a service and then poking at it.

This means that service must be able to work correctly in any circumstance.

For example, a class that expects to only be used during the simulation portion of the game loop and not during rendering may not work as a service — it wouldn’t be able to ensure that it’s being used at the right time.

So, if a class expects to only be used in a certain context, it’s safest to avoid exposing it to the entire world with this pattern.

Sample Code

Getting back to our audio system problem, let’s address it by exposing the system to the rest of the codebase through a service locator.

The service

We’ll start off with the audio API.

This is the interface that our service will be exposing:

class Audio

{

public:

virtual ~Audio() {}

virtual void playSound(int soundID)

= 0;

virtual void stopSound(int soundID)

= 0;

virtual void stopAllSounds() = 0;

};

A real audio engine would be much more complex than this, of course, but this shows the basic idea.

What’s important is that it’s an abstract interface class with no implementation bound to it.

The service provider

By itself, our audio interface isn’t very useful.

We need a concrete implementation.

This book isn’t about how to write audio code for a game console, so you’ll have to imagine there’s some actual code in the bodies of these functions, but you get the idea:

class ConsoleAudio : public Audio

{

public:

virtual void playSound(int soundID)

{

// Play sound using console audio api...

}

virtual void stopSound(int soundID)

{

// Stop sound using console audio api...

}

virtual void stopAllSounds()

{

// Stop all sounds using console audio api...

}

};

Now we have an interface and an implementation.

The remaining piece is the service locator — the class that ties the two together.

A simple locator

The implementation here is about the simplest kind of service locator you can define:

class Locator

{

public:

static Audio* getAudio() { return service_; }

static void provide(Audio* service)

{

service_ = service;

}

private:

static Audio* service_;

};

Техника, примененная тут, называется внедрением зависимостей (Dependency Injection), неуклюжий жаргон для весьма простой идеи.

Скажем, есть класс, зависимый от другого.

В нашем случае, нашему классу Locator нужен экземпляр службы Audio.

Обычно, локатор сам отвечает за создание такого экземпляра.

Принцип внедрения зависимостей вместо этого декларирует, что внешний код отвественен за внедрение зависимости в тот объект, которому такая зависимость нужна.

Статичная функция getAudio() находит службу - мы можем вызвать ее откуда угодно, и она выдаст нам готовый к использованию экземпляр службы Audio.

void someGameCode()

{

Audio *audio = Locator::getAudio();

audio->playSound(VERY_LOUD_BANG)

;

}

Способ "нахождения" очень прост, он основан на том, что внешний код регистрирует поставщика службы прежде, чем кто-либо попытается воспользоваться службой.

При запуске игра вызывает примерно такой код:

void initGame()

{

ConsoleAudio *audio = new ConsoleAudio();

Locator::provide(audio)

;

}

Здесь ключевым моментом является то, что наша функция someGameCode() не в курсе конкретной реализации класса ConsoleAudio, а только его абстрактного интерфейса Audio.

Не менее важно и то, что класс локатора также не связан с конкретным поставщиком службы.

Единственно место в коде, которое знает о конкретном классе - это функция инициализации, регистрирующая службу.

Тут дополнительный уровень декомпозиции: интерфейс Audio не в курсе того, что он используется в целой куче мест через Service Locator.

Он знает лишь, лишь что он - просто обычный абстрактный базовый класс.

Это полезно, потому что означает, что мы можем применять этот паттерн к существующим классам, не "заточенным" под него.

В этом его отличие от Singleton, который влияет на дизайн самого класса службы.

Null-сервис

Пока что наша реализация одновременно и проста и довольно гибка.

Но у нее есть серьезный дефект: если мы попробуем использовать службу перед тем, как ее поставщик был зарегистрирован, мы получим NULL.

И если вызывающий код это не проверит, то будет сбой игры.

Я порой слышал, как это называют "временным связыванием": два раздельных участка кода, которые, чтобы программа корректно работала, должны вызываться в правильном порядке.

All stateful software has some degree of this, but as with other kinds of coupling, reducing it makes the codebase easier to manage.

Fortunately, there’s another design pattern called “Null Object” we can use to address this.

The basic idea is that in places where we would return NULL when we fail to find or create an object, we instead return a special object that implements the same interface as the desired object.

Its implementation basically does nothing, but allows code that receives the object to safely continue on as if it had received a “real” one.

To use this, we’ll define another “null” service provider:

class NullAudio: public Audio

{

public:

virtual void playSound(int soundID)

{ /* Do nothing.

*/ }

virtual void stopSound(int soundID)

{ /* Do nothing.

*/ }

virtual void stopAllSounds()        { /* Do nothing.

*/ }

};

As you can see, it implements the service interface, but doesn’t actually do anything.

Now, we change our locator to this:

class Locator

{

public:

static void initialize() { service_ = &nullService_; }

static Audio& getAudio() { return *service_; }

static void provide(Audio* service)

{

if (service == NULL)

{

// Revert to null service.

service_ = &nullService_;

}

else

{

service_ = service;

}

}

private:

static Audio* service_;

static NullAudio nullService_;

};

You may notice we’re returning the service by reference instead of by pointer now.

Since references in C++ are (in theory!)

never NULL, returning a reference is a hint to users of the code that they can expect to always get a valid object back.

The other thing to notice is that we’re checking for NULL in the provide() function instead of the accessor.

That requires us to call initialize() early on to make sure that the Locator initially correctly defaults to the null provider.

In return, it moves the branch out of getAudio(), which will save us a couple of cycles every time the service is accessed.

Calling code will never know that a “real” service wasn’t found, nor does it have to worry about handling NULL.

It’s guaranteed to always get back a valid object.

This is also useful for intentionally failing to find services.

If we want to disable a system temporarily, we now have an easy way to do so: simply don’t register a provider for the service and the locator will default to a null provider.

Turning off audio is handy during development.

It frees up some memory and CPU cycles.

More importantly, when you break into a debugger just as a loud sound starts playing, it saves you from having your eardrums shredded.

There’s nothing like twenty milliseconds of a scream sound effect looping at full volume to get your blood flowing in the morning.

Logging decorator

Now that our system is pretty robust, let’s discuss another refinement this pattern lets us do: decorated services.

I’ll explain with an example.

During development, a little logging when interesting events occur can help you figure out what’s going on under the hood of your game engine.

If you’re working on AI, you’d like to know when an entity changes AI states.

If you’re the sound programmer, you may want a record of every sound as it plays so you can check that they trigger in the right order.

The typical solution is to just litter the code with calls to some log() function.

Unfortunately, that replaces one problem with another: now we have too much logging.

The AI coder really doesn’t care when sounds are playing, and the sound person doesn’t care about AI state transitions, but now they both have to wade through each other’s messages.

Ideally, we would be able to selectively enable logging for just the stuff we care about, and in the final game build, there’d be no logging at all.

If the different systems we want to conditionally log are exposed as services, then we can solve this using the Decorator pattern.

Let’s define another audio service provider implementation like this:

class LoggedAudio : public Audio

{

public:

LoggedAudio(Audio &wrapped)

: wrapped_(wrapped)

{}

virtual void playSound(int soundID)

{

log("play sound");

wrapped_.playSound(soundID)

;

}

virtual void stopSound(int soundID)

{

log("stop sound");

wrapped_.stopSound(soundID)

;

}

virtual void stopAllSounds()

{

log("stop all sounds");

wrapped_.stopAllSounds();

}

private:

void log(const char* message)

{

// Code to log message...

}

Audio &wrapped_;

};

As you can see, it wraps another audio provider and exposes the same interface.

It forwards the actual audio behavior to the inner provider, but also logs each sound call.

If a programmer wants to enable audio logging, they call this:

void enableAudioLogging()

{

// Decorate the existing service.

Audio *service = new LoggedAudio(Locator::getAudio());

// Swap it in.

Locator::provide(service)

;

}

Now any calls to the audio service will be logged before continuing as before.

And, of course, this plays nicely with our null service, so you can both disable audio and yet still log the sounds that it would play if sound were enabled.

Design Decisions

We’ve covered a typical implementation, but there’s a couple of ways that it can vary, based on differing answers to a few core questions:

How is the service located?

Outside code registers it:

This is the mechanism our sample code uses to locate the service, and is the most common design I see in games:

It’s fast and simple.

The getAudio() function simply returns a pointer.

It will often get inlined by the compiler, so we get a nice abstraction layer at almost no performance cost.

We control how the provider is constructed.

Consider a service for accessing the game’s controllers.

We have two concrete providers: one for regular games and one for playing online.

The online provider passes controller input over the network so that, to the rest of the game, remote players appear to just be using local controllers.

To make this work, the online concrete provider needs to know the IP address of the other remote player.

If the locator itself was constructing the object, how would it know what to pass in?

The locator class doesn’t know anything about online at all, much less some other user’s IP address.

Externally registered providers dodge the problem.

Instead of the locator constructing the class, the game’s networking code instantiates the online-specific service provider, passing in the IP address it needs.

Then it gives that to the locator, who knows only about the service’s abstract interface.

We can change the service while the game is running.

We may not use this in the final game, but it’s a neat trick during development.

While testing, we can swap out, for example, the audio service with the null service we talked about earlier to temporarily disable sound while the game is still running.

The locator depends on outside code.

This is the downside.

Any code accessing the service presumes that some code somewhere has already registered it.

If that initialization doesn’t happen, we’ll either crash or have a service mysteriously not working.

Bind to it at compile time:

The idea here is that the “location” process actually occurs at compile time using preprocessor macros.

Like so:

class Locator

{

public:

static Audio& getAudio() { return service_; }

private:

#if DEBUG

static DebugAudio service_;

#else

static ReleaseAudio service_;

#endif

};

Locating the service like this implies a few things:

It’s fast.

Since all of the real work is done at compile time, there’s nothing left to do at runtime.

The compiler will likely inline the getAudio() call, giving us a solution that’s as fast as we could hope for.

You can guarantee the service is available.

Since the Locator owns the service now and selects it at compile time, we can be assured that if the game compiles, we won’t have to worry about the service being unavailable.

You can’t change the service easily.

This is the major downside.

Since the binding happens at build time, any time you want to change the service, you’ve got to recompile and restart the game.

Configure it at runtime:

Over in the khaki-clad land of enterprise business software, if you say “service locator”, this is what they’ll have in mind.

When the service is requested, the locator does some magic at runtime to hunt down the actual implementation requested.

Reflection is a capability of some programming languages to interact with the type system at runtime.

For example, we could find a class with a given name, find its constructor, and then invoke it to create an instance.

Dynamically-typed languages like Lisp, Smalltalk, and Python get this by their very nature, but newer static languages like C# and Java also support it.

Typically, this means loading a configuration file that identifies the provider, then using reflection to instantiate that class at runtime.

This does a few things for us:

We can swap out the service without recompiling.

This is a little more flexible than a compile-time bound service, but not quite as flexible as a registered one where you can actually change the service while the game is running.

Non-programmers can change the service.

This is nice for when the designers want to be able to turn certain game features on and off, but aren’t comfortable mucking through source code.

(Or, more likely, the coders aren’t comfortable with them mucking through it.)

The same codebase can support multiple configurations simultaneously.

Since the location process has been moved out of the codebase entirely, we can use the same code to support multiple service configurations simultaneously.

This is one of the reasons this model is appealing over in enterprise web-land: you can deploy a single app that works on different server set-ups just by changing some configs.

It’s less useful in games.

Console hardware is pretty well standardized, and even PC games target a certain baseline specification.

It’s complex.

Unlike the previous solutions, this one is pretty heavyweight.

You have to create some configuration system, possibly write code to load and parse a file, and generally do some stuff to locate the service.

Time spent writing this code is time not spent on other game features.

Locating the service takes time.

And now the smiles really turn to frowns.

Going with runtime configuration means you’re burning some CPU cycles locating the service.

Caching can minimize this, but that still implies that the first time you use the service, the game’s got to go off and spend some time hunting it down.

Game developers hate burning CPU cycles on something that doesn’t improve the player’s game experience.

What happens if service could not be located?

Let the user handle it:

The simplest solution is to pass the buck.

If the locator can’t find the service, it just returns NULL.

This implies:

It lets users determine how to handle failure.

Some users may consider failing to find a service a critical error that should halt the game.

Others may be able to safely ignore it and continue.

If the locator can’t define a blanket policy that’s correct for all cases, then passing the failure down the line lets each callsite decide for itself what the right response is.

Users of the service must handle the failure.

Of course, the corollary to this is that each callsite must check for failure to find the service.

If almost all of them handle failure the same way, that’s a lot duplicate code spread throughout the codebase.

If just one of the potentially hundreds of places that use the service fails to make that check, our game is going to crash.

Halt the game:

I said that we can’t prove that the service will always be available at compile-time, but that doesn’t mean we can’t declare that availability is part of the runtime contract of the locator.

The simplest way to do this is with an assertion:

class Locator

{

public:

static Audio& getAudio()

{

Audio* service = NULL;

// Code here to locate service...

assert(service != NULL)

;

return *service;

}

};

An assertion function is a way of embedding a contract into your code.

When assert() is called, it evaluates the expression passed to it.

If it evaluates to true, then it does nothing and lets the game continue.

If it evaluates to false, it immediately halts the game at that point.

In a debug build, it will usually bring up the debugger or at least print out the file and line number where the assertion failed.

An assert() means, “I assert that this should always be true.

If it’s not, that’s a bug and I want to stop now so you can fix it.”

This lets you define contracts between regions of code.

If a function asserts that one of its arguments is not NULL, that says, “The contract between me and the caller is that I will not be passed NULL.”

Assertions help us track down bugs as soon as the game does something unexpected, and not later when that error finally manifests as something visibly wrong to the user.

They are fences in your codebase, corraling bugs so that they can’t escape from the code that created them.

If the service isn’t located, the game stops before any subsequent code tries to use it.

The assert() call there doesn’t solve the problem of failing to locate the service, but it does make it clear whose problem it is.

By asserting here, we say, “failing to locate a service is a bug in the locator.”

So what does this do for us?

Users don’t need to handle a missing service.

Since a single service may be used in hundreds of places, this can be a significant code saving.

By declaring it the locator’s job to always provide a service, we spare the users of it from having to pick up that slack.

The game is going to halt if the service can’t be found.

On the off chance that a service really can’t be found, the game is going to halt.

This is good in that it forces us to address the bug that’s preventing the service from being located (likely some initialization code isn’t being called when it should)

, but it’s a real drag for everyone else who’s blocked until it’s fixed.

With a large dev team, you can incur some painful programmer downtime when something like this breaks.

Return a null service:

We showed this refinement in our sample implementation.

Using this means:

Users don’t need to handle a missing service.

Just like the previous option, we ensure that a valid service object will always be returned, simplifying code that uses the service.

The game will continue if the service isn’t available.

This is both a boon and a curse.

It’s helpful in that it lets us keep running the game even when a service isn’t there.

This can be really helpful on a large team when a feature we’re working on may be dependent on some other system that isn’t in place yet.

The downside is that it may make it harder to debug a missing service.

Imagine that some code in the game uses a service to access some data and then makes a decision based on it.

If it gets a null service instead of a real one and gets dummy data from it, the game may not behave as expected.

It could take effort to trace that issue back to the fact that a service wasn’t there when we thought it would be.

Among these options, the one I see used most frequently is simply asserting that the service will be found.

By the time a game gets out the door, it’s been very heavily tested, and it will likely be run on a reliable piece of hardware.

The chances of a service failing to be found by then are pretty slim.

On a larger team, I encourage you to throw a null service in.

It doesn’t take much effort to implement, and can spare you from some downtime during development when a service isn’t available.

It also gives you an easy way to turn a service off if it’s buggy or is just distracting you from what you’re working on.

What is the scope of the service?

Up to this point, we’ve assumed that the locator will provide access to the service to anyone who wants it.

While this is the typical way the pattern is used, another option is to limit access to a single class and its descendants, like so:

class Base

{

// Code to locate service and set service_...

protected:

// Derived classes can use service

static Audio& getAudio() { return *service_; }

private:

static Audio* service_;

};

With this, access to the service is restricted to classes that inherit Base.

There are advantages either way:

If access is global:

It encourages the entire codebase to all use the same service.

Most services are intended to be singular.

By allowing the entire codebase to have access to the same service, we can avoid random places in code instantiating their own providers because they can’t get to the “real” one.

We lose control over where and when the service is used.

This is the obvious cost of making something global: anything can get to it.

The Singleton chapter has a full cast of characters for the horrorshow that global scope can spawn.

If access is restricted to a class:

We control coupling.

This is the main advantage.

By limiting a service to a branch of the inheritance tree, we can make sure systems that should be decoupled stay decoupled.

It can lead to duplicate effort.

The potential downside is that if a couple of unrelated classes do need access to the service, they’ll each need to have their own reference to it.

Whatever process is used to locate or register the service will have to be duplicated between those classes.

(The other option is to change the class hierarchy around to give those classes a common base class, but that’s probably more trouble than it’s worth.)

My general guideline is that if the service is restricted to a single domain in the game then limit its scope to a class.

For example, a service for getting access to the network can probably be limited to online classes.

Services that get used more widely like logging should be global.

See Also

The Service Locator pattern is a sibling to Singleton in many ways, so it’s worth looking at both to see which is most appropriate for your needs.

The Unity framework uses this pattern in concert with the Component pattern in its GetComponent() method.

Microsoft’s XNA framework for game development has this pattern built into its core Game class.

Each instance has a GameServices object that can be used to register and locate services of any type.

Переведено на Нотабеноиде
http://notabenoid.com/book/51192/215228

Переводчики: Deo, bubenok

