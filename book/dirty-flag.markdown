^title Грязный флаг
^section Низкоуровневая оптимизация

## Общая идея

*Избегайте ненужной работы, пока не понадобится ее результат.*

## Предпосылки

"Флаг" и "бит" являются практически синонимами в программировании: они оба могут
находится только в одном и двух состояний. Можно назвать их "правда" или "ложь",
иногда "установлен" и "очищен". Я буду использовать оба варианта. Так что текущую
главу можно было назвать <span name="specific">"Грязный бит"</span>, но я решил
использовать более нейтральный вариант.

<aside name="specific">

Редакторы википедии менее щепетильны, чем я, и выбрали
[грязный бит](http://ru.wikipedia.org/wiki/Грязный_бит).

</aside>

### Как найти лодку в море

Множество игр занимаются построение *графа сцены*. Это большая структура данных,
в которой находятся все объекты игры. Рендерер использует его, чтобы определить,
где их нарисовать на экране.

В простом случае, граф -- это плоский список объектов. У каждого объекта есть
модель или другой графический примитив, и
<span name="transform">*матрица преобразований*</span> (далее -- преобразование),
которая описывает координаты объекта, поворот и степень масштабирования. Чтобы
передвинуть или повернуть объект, мы просто меняем эти значения.

<aside name="transform">

Детали того, *как* хранить преобразование, и как им манипулировать, к сожалению,
выходят за рамки разговора. Смешно говорить, но это действительно матрица 4 на 4.
Чтобы применить два преобразования к объекту -- например,
передвинуть и потом повернуть -- достаточно перемножить две матрицы.

Как и почему это работает -- домашнее задание для читателей.

</aside>

Когда рендерер рисует объект, он берет модель объекта, применяет к ней
преобразование, и затем отрисовывает эту модель в сцене. И, если бы у нас был
бы *пул* сцены, а не *граф*, то все было бы просто.

Однако, большинство графов имеют <span name="hierarchical">*иерархию*</span>.
У объектов в графе может быть родительский объект, к которому он прикреплен.
В этом случае, преобразование объекта применяется относительно положения родителя,
а не абсолютных координат.

Например, наша игра отрисовывает пиратский корабль в море. Пусть на верху мачты
сидит на марсе пират, а на плече у него -- попугай. Преобразование корабля
описывает его положение в море. Преобразование "дозорной бочки"
описывает её положение на корабле, и так далее.

<span name="pirate"></span>
<img src="images/dirty-flag-pirate.png" alt="На пиратском корабле дозорная бочка с пиратом с попугаем на плече." />

<aside name="pirate">

Осторожно, рисовал программист!

</aside>

Когда родительский объект передвигается, автоматически смещаются и все его дети.
И если мы поменяем локальное преобразование корабля, то бочка, пират и попугай все
вместе должны передвинуться вместе с ним. Если бы мы вручную меняли преобразования
всех объектов, которые находятся на двигающемся корабле, чтобы ничего не разъехалось,
мы бы заработали настоящая <span name="slide">головная боль</span>.

<aside name="slide">

Честно говоря, когда вы в море, то *приходится* самому следить за своими координатами,
чтобы не вывалится за борт. Может быть, мне стоило придумать более подходящий пример.

</aside>

Но когда мы непосредственно приступили к отрисовке попугая, нам нужны его абсолютные
координаты. Будем называть *локальным преобразованием* такое преобразование относительно
родительского объекта. А для того чтобы рисовать, будем вычислять *глобальное преобразование*.

### Локальные и глобальные преобразования

Рассчитать глобальное преобразование для объекта несложно: надо подниматься по
цепочке родителей вверх до корня дерева, а затем спускаться обратно, накладывая
преобразования друг на друга поочередно. Тогда глобальное преобразование попугая будет:

<span name="degenerate"></span>
<img src="images/dirty-flag-multiply.png" alt="Глобальное преобразованеи попугая зависит от наложения локальных преобразований корабля, марса, пирата и попугая." />

<aside name="degenerate">

В частном случае, когда у объекта нет родителя, его локальное и глобальное
преобразование -- совпадают.

</aside>

Нам нужно пересчитать глобальное преобразование для каждого объекта каждый кадр,
так что, даже при малом количестве перемножений матриц, это та часть кода, где
производительность критична. Поддерживать их в актуальном состоянии непросто,
потому что когда родительский объект двигается, это влияет и на него,
и на всех его детей рекурсивно.

Очевидный вариант -- это вычислять преобразования на лету
при отрисовке. Каждую отрисовку мы будем спускаться по графу, начиная с
самого верха, и вычислять глобальное преобразование для каждого объекта
и отрисовывать.

Но это ужасная трата драгоценного процессорного времени! На практике, большинство
объектов не меняют своего положения каждый кадр -- вспомните про все эти статические
объекты, из которых состоит уровень. Вычислять каждый раз их глобальное преобразование,
когда они не изменялись, -- лишняя работа.

### Кешируемые глобальные преобразования

Очевидный подход -- кэшировать их. В каждом объекте мы будем хранить локальное
и глобальное преобразование. При отрисовке мы используем глобальное преобразование,
которая уже вычислено. И если объект не сдвигался в этот кадр, то оно всегда
актуально -- и все довольны.

Когда же объект *передвинулся*, в простом случае достаточно обновить его глобальное
преобразование. Но не забудьте об иерархии! Когда двигается родитель, нужно
пересчитать его преобразование и *всех его детей,
рекурсивно*.

Представьте, что у нас довольно сложная игра. В каждом цикле корабль качается на
волнах, дозорная бочка ходит вместе с матчей, пирата постоянно тошнит, а попугай
прыгает через голову. Нам придется менять четыре локальных преобразования. Если
мы сразу же начнем пересчитывать глобальные, то во что
это выльется?

<span name="stars"></span>
<img src="images/dirty-flag-update-bad.png" alt="Каждый раз, когда объект двигается, глобальное преобразование пересчитывается моментально и избыточно." />

<aside name="stars">

Если посмотреть на линии, отмеченные &#x2605;, то можно увидеть, что мы *четыре*
раза пересчитывали глобальное преобразование попугая, хотя нам нужны были только
результаты последнего расчета.

</aside>

Мы передвинули всего лишь четыре объекта, а пришлось пересчитать *десять* глобальных
преобразований. Шесть бесполезных вычислений будут выкинуты, потому что их результат
нам не интересен. Мы четыре раза пересчитали попугая, хотя он был
отрисован всего раз.

Проблема в том, что каждое глобальное преобразование зависит от нескольких локальных.
Так как мы пересчитывали их сразу после того, как происходило *каждое* изменение,
в результате нам пришлось пересчитать глобальное преобразование для одного и того же
объекта столько раз, сколько локальных преобразований родителей изменилось.

### Отложенные вычисления

Мы можем решить эту проблему <span name="decoupling">разрывом зависимости</span> изменений
глобального преобразования от обновлений локальных. Это позволит изменять набор
локальных преобразований одним проходом, и только *потом* пересчитать те
глобальные преобразования, которые это затронуло, тогда, когда они
понадобятся для отрисовки.

<aside name="decoupling">

Занимательно, как много архитектурных решений основаны на намеренном
нарушении правил.

</aside>

Для этого мы добавим флаг к каждому объекту в графе и будем выставлять его тогда,
когда будет менятся локальное преобразование объекта. Когда нам понадобиться глобальное
преобразование, мы проверим этот флаг, и если он выставлен, то пересчитаем глобальное
преобразование и очистим флаг. Этот флаг будет сигнализировать нам, нужно обновлять
матрицы, или нет. По причинам, которые мне не совсем ясны, термин для такой "неточности"
данных -- это "грязные данные". Вот и получается *грязный флаг*.

Если мы применим этот подход, и повторим пример с четырьмя объектами, то в
результате у нас получится:

<img src="images/dirty-flag-update-good.png" alt="Откладывая рассчеты до конца всех передвижений, мы сделаем их один раз." />

Это то, на что мы надеялись, - глобальное преобразование для каждого затронутого
объекта вычисляется ровно один раз. С помощью всего одного бита, этот паттерн
делает сразу несколько вещей:

 *  Сводит все множество изменений локальных преобразований
    в родительской цепочке к одному пересчету на объект.

 *  Избавляет от необходимости пересчитывать неизмененные объекты.

 *  И мини-бонус: если объект был удален до того, как он был отрисован,
    то его глобальное преобразование не рассчитывается вовсе.

## Общий подход

Есть набор **основных данных**, которые могут измениться. И есть **вторичные данные**,
которые вычисляются из основных с помощью некоторого **дорогого процесса**. **"Грязный"" флаг**
служит для определения актуальности вторичных данных и **их соответствие основным**. Когда
запрашиваются вторичные данные, если флаг выставлен, необходимо **рассчитать вторичные
данные заново и очистить флаг**. В обратном случае используются закешированные
вторичные данные, рассчитаные ранее.

## Когда использовать

По сравнению с другими паттернами в этой книге, этот решает довольно специфическую
задачу. Также, как и с другими оптимизациями, его использование зависит от того, достаточно
ли большая проблема производительности, чтобы компенсировать выросшую сложность кода.

"Грязный флаг" применим к двум процессам: *вычисления* и
*синхронизация*. В обоих случаях, процесс передачи изменений от первичных данных к
вторичным либо трудоемкий по времени, либо дорог по другим причинам.

В нашем примере с графом сцены вычисления медленные, потому что там много математики.
При задаче синхронизации проблема чаще заключается в том,
что вторичные данные находятся *где-то еще* -- на диске или
в сети на другой машине -- и дорога сама доставка данных из пункта A в пункт B.

Вот ещё пара требований:

 *  **Первичные данные изменяются чаще, чем ипользуются вторичные.**
    Паттерн избегает манипуляций с вторичными данными при изменениях
    первичных до того как они понадобятся. Если есть жесткая необходимость
    обновить вторичные данные сразу же после изменения
    основных -- этот паттерн не для вас.

 *  **Трудно реализовать инкрементальное обновление.**
    Допустим, наш пиратский корабль может вести награбленное добро. И нам нужно
    знать вес груза в трюме. Мы
    *можем* использовать этот паттерн и указать флагом на общий вес. Каждый раз,
    когда мы добавляем или убираем сундук, мы выставляем флаг. Когда нам нужен
    общий вес, мы пересчитываем добрло в сундуках и сбрасываем флаг.

    Конечно, еше более простое решение -- *пересчитывать сумму*. Когда мы добавляем или
    убираем вес, можно просто прибавлять или вычитать это число из общего веса. Если
    мы можем пренебречь затратами на подобную работу, и при этом поддержать актуальность
    первичных данных, то это выгодное решение.

Из всего этого кажется, что техникой грязного флага тяжело воспользоваться. Но можно
найти место, где её применить. Если <span name="hacks">поискать</span>
слово "dirty" в коде игры средней сложности, то подобные примеры легко найдутся.

<aside name="hacks">

По моему опыту, вы найдете и множество комментарии с извинениями за "грязный"
хак.

</aside>

## Особенности

Даже если вы решились на использование этого паттерна, надо быть готовым к
моментам, который доставят некоторый дискомфорт.

### Затраты на чрезмерно отложенные вычисления

Паттерн откладывает затратные вычисления до того момента, когда результаты действительно
понадобятся, -- а когда они становяться нужными, они нужны *практически сразу*. Но ведь
из-за этого мы и выбрали этот паттерн -- потому что вычисления медленные!

В нашем примере, это не проблема, потому что перевод локального преобразования в
глобальное быстр достаточно, чтобы не задерживать отрисовку. Однако, легко представить
другие ситуации, когда вычисления вызовут задержки, заметные невооруженным взглядом.
И если игрок не получит результат этих вычислений сразу же, это будет весьма неприятная
<span name="gc">пауза</span>.

Ещё одна трудность -- если что-то пойдет не так в процессе вычислений, то восстановиться
после такой ошибки тяжело. В случае, если вы используете отложенные вычисления
для хранения состояний, то это может добавить головной боли.

Например, текстовые редакторы не сразу сохраняют файл на диск. Как правило,
маленькая звездочка в заголовке окна -- это буквально "грязный флаг".
Здесь первичные данные -- это открытый в редакторе документ, а вторичные --
файл на диске.

<img src="images/dirty-flag-title-bar.png" alt="В заголовке окна маленькая иконка отображает несохраненное состояние." />

Много программ не сохраняют изменения на диск до тех пор, пока приложение или
документ не закроются. Это нормально, но если неожиданно
выдернуть питание, то шедевр не увидит своих фанатов.

Функция автоматического восстановления в редакторах компенсирует этот
недостаток. Частота автосохранения -- это выбранный компромисс
между "не потерять слишком много, если все накроется" и "экономить время и
не утруждать винчестер лишней работой".

<aside name="gc">

Это отражает трудности, с которыми сталкиваются стратегии сборки мусора в системах
с автоматическим управлением памятью. При подсчете ссылок память освобождается сразу же,
как только она становиться не нужна, но при этом тратится процессорное время на
обновление счетчика ссылок каждый раз, когда они изменяются.

Простейшие сборщики откладывают освобождение памяти до тех пор, пока она реально не понадобится.
Но эта задержка при "паузе сборщика мусора" может повесить всю игру,
пока сборщик не пройдется по куче.

Есть ещё варианты между этими крайностями. Например, отложенный подсчет ссылок или
инкрементальный сборщик, который не ставит весь процесс на паузу, хотя
собирает память менее интенсивно, чем прямые счетчики без stop-the-world.

</aside>

### Не забывайте выставлять флаг *каждый раз*, когда состояние изменилось

Так как вторичные данные вычисляются из основных, это практически
кэш. А где появляется кэш, то там появляется и
<span name="cache">*инвалидация кэша*</span> -- внимательное слежение за
актуальностью данных в нем. В текущем паттерне, это означает своевременное
выставление флага при *любом* изменении основных данных.

<aside name="cache">

Фил Карлтон верно подметил, что "есть только две трудные задачи в области информатики:
инвалидация кеша и придумывание названий".

</aside>

Стоит пропустить всего одно место, и программа начнет использовать устаревшие данные.
Это приводит в замешательство игроков и приводит к трудно отслеживаемым ошибкам. Когда
используете этот паттерн, убедитесь, что грязный флаг выставляется после
любого изменения в первичных данных.

Одним из способов следить за этим моментом является инкапсуляция модификаций первичных
данных за некоторым интерфейсом. Если все изменения состояния используют
единственный API, то можно выставлять этот флаг там и забыть об этой проблеме
на долгое время.

### На хранение вторичных данных требуется память

<span name="sync"></span>

Когда вторичные данные понадобятся, и грязный флаг *не* поднят, то используются
уже вычисленные результаты. Это очевидно, но это вынуждает хранить эти результаты
в памяти постоянно, так как они могут понадобиться позже.

<aside name="sync">

Это не относится к ситуации, когда вы синхронизируете
данные в какое-то другое место. В этом случае, вторичные данные обычно могут
вообще не храниться в памяти.

</aside>

Если бы мы не использовали этот паттерн, то просто вычисляли бы вторичные данные
каждый раз, когда они понадобятся, и уничтожали сразу после использования. Это помогает
избежать затрат на хранение их в памяти ценой
постоянных вычислений.

Как всегда при оптимизациях, мы <span name="trade">платим</span>
памятью за скорость. В обмен за хранение вычисленных результатов в памяти,
вы получаете возможность не тратить время на повторые вычисления, если ничего не изменилось.
Эта сделка имеет смысл, если вычисления дороги, а память -- дешева. Если
у вас времени больше, чем памяти, то выгоднее каждый раз пересчитывать,
когда это нужно.

<aside name="trade">

И, наоборот, алгоритмы сжатия предлагают противоположную сделку: они оптимизируют
*место* для хранения данных в обмен на время на их распаковку.

</aside>

## Примеры

Давайте предположим, что у нас необычно длинный список требований, и посмотрим
как наш паттерн будет смотреться в коде. Как я упоминал ранее, математика операций
над матрицами не входит в эту книгу, так что я
спрячу всю логику в абстрактный класс, реализация которого существует где-то в эфире:

^code transform

Единственная операция, которая нам понадобится, это `combine()`. Она выдает нам
глобальное преобразование, комбинируя все локальные по родительской цепочке.
Так же есть метод `origin`, который возвращает единичную матрицу,
без всяких переносов, вращений и так далее.

Теперь набросаем класс, который будет объектом в нашем графе сцены. Это самый минимум,
который нам нужен *перед* применением паттерна:

^code graph-node

У каждой ноды есть локальное преобразование, которая описывает её положение
относительно родительской. Ещё у неё есть `mesh_` -- это реальная графическая модель для объекта
(`mesh_` может быть `NULL`, если это невизуальная нода, которая нужна для группировки
остальных). Наконец, у каждой ноды есть список дочерних нод, возможно, пустой.

Со всем этим, граф сцены -- это просто единственная корневая `GraphNode`, чьи
дети (внуки, и так далее) являются объектами мира:

^code scene-graph

Чтобы отрисовать граф, нам нужно пройтись по всему дереву нод, начиная с корня
и вызвать следующую функцию для графики каждой ноды
с правильным глобальным преобразованием:

^code render

Мы не будем её реализовывать здесь. Но если бы стали, то там бы была всякая магия,
связанная с отрисовыванием модели в данной точке пространства. Если мы сможем
вызвать эту функцию правильно и быстро для каждой ноды в графе -- мы
будем счастливы.

### Неоптимальный обход

Будем пачкать руки. Начнем с простого обхода, который вычисляет глобальное
преобразование на лету. Это не будет оптимально,
зато это будет просто. Добавим новый метод к `GraphNode`:

^code render-on-fly

Будем передавать глоабльное преобразование родительской ноды используя `parentWorld`.
Тогда, чтобы получить преобразование для *текущей* ноды, надо просто скомбинировать
родительское глобальное и локальное преобразование. Не придется подниматься *вверх*
по цепи родителей, чтобы высчитать глобальное преобразование, потому что мы получаем
её последовательно спускаясь *сверху-вниз*.

Затем сохраним глобальное преобразование ноды в переменную `world` для хранения
и отрисуем модель, если она есть. Наконец, мы проделаем то же самое для дочерних нод,
передавая туда глобальное преобразование *текущей* ноды. Вот и получился простой
рекурсивный алгоритм.

Чтобы нарисовать всю сцену, запустим эту функцию для корневой ноды:

^code render-root

### Сыграем грязно

Итак, этот код делает все правильно -- отрисовывает все объекты в нужных местах
-- но не совсем оптимально. Он вызывает `local_.combine(parentWorld)`
для каждой ноды в графе, для каждого кадра. Посмотрим, как наш паттерн это изменит.
Во-первых, мы добавим два поля в `GraphNode`:

^code dirty-graph-node

Поле `world_` кэширует текущее, вычисленное значение глобального преобразования, а
`dirty_` -- это и есть грязный флаг. Заметим, что изначально он выставлен в `true`.
Это значит, что когда мы создаем новую ноду, его глобальное преобразование ещё не рассчитано.
При рождении она изначально неактуальна.

Единственная причина, по который нам нужен паттерн "грязный флаг", это то,
что объекты *двигаются*. Поэтому добавим поддержку для этого:

^code set-transform

Важно что здесь мы выставляем флаг в `true`. Что-нибудь забыли?
Правильно: дочерние ноды!

Когда родительская нода двигается, все преобразования её дочерних элементов
становятся невалидными. Но здесь мы не меняем их флаги. Мы *могли бы*
это сделать, но это рекурсивно и медленно. Вместо этого мы используем
другую идею в процедуре рисования. Вот смотрите:

<span name="branch"></span>

^code dirty-render

<aside name="branch">

Это основано на явном предположении, что проверка `if` выполняется быстрее,
чем перемножение матриц. Интуитивно, это так - проверка одного бита быстрее,
чем операции с плавающей точкой.

Однако, современные процессоры фантастически сложны. В них широко используются
*вычислительные конвейеры*. Условный переход, как наш `if`,
можем вызвать *промах предсказания* и трату циклов процессора на
перезагрузку конвейера.

В главе <a href="data-locality.html" class="pattern">Компактность данных</a> написано
больше о том, как процессоры стараются работать быстрее и как можно избежать
подобных ловушек.

</aside>

Это похоже на первоначальную примитивную реализацию. Ключевое изменение здесь в том,
что мы проверяем нужно ли обновлять глобальное преобразование для ноды.
И мы сохраняем результат её вычисления в поле класса вместо локальный переменной.
Если преобразование ноды "чистое", мы можем пропустить вызов `combine()`
совсем и использовать старое, но все ещё актуальное
значение.

Тут используется <span name="clever">хитрый</span> параметр `dirty`. Он будет
`true`, если какая-то нода выше текущей по дереву была грязной.
Также, как `parentWorld` обновляет глобальное преобразование инкрементально
в процессе обхода вниз по дереву, `dirty` говорит нам, не были ли изменены
объекты в родительской цепочке.

Это позволяет избежать установку флага `dirty_` рекурсивно
для всех дочерних нод в `setTransform()`. Вместо этого, мы просто передаем
родительский грязный флаг к дочерним элементам во время отрисовки и
учитываем его при решении, надо ли обновлять глобальное преобразование.

В конечном результате получается именно то, что нужно: изменение локального преобразования
ноды приводит только к нескольким присваиваниям, а отрисовка графа пересчитывает
минимум преобразований, которые изменились за последнее время.

<aside name="clever">

Заметьте, что этот трюк работает, потому что функция `render()` *единственное* место
в `GraphNode`, которой нужна актуальное глобальное преобразование. Если она потребуется
в других местах, то надо придумывать что-то иное.

</aside>

## Выбор архитектуры

Этот паттерн весьма прост, осталось ли принять пару решений:

### Когда очищать флаг?

* **Когда нужен результат:**

    * *Это убирает необходимость вычислений вообще, если результат никогда не нужен.*
        Получаем огромный выигрыш, если первичные данные изменяются гораздо чаще,
        чем нужны вторичные.

    * *Если вычисления занимают много времени, это может вызвать значительную паузу.*
        Можно получить неприятный результат, если отложить вычисления до момента,
        когда они понадобятся игроку. Часто всего это не будет проблемой, если
        они достаточно быстры. Но если нет, то придется сделать эту работу заранее.

* **В точно определенных точках:**

    Иногда есть точка во времени или прогрессе игры, где вполне
    естественно произвести отложенные вычисления. Например,
    мы можем сохранить игру, когда пиратский корабль входит в порт. Или,
    если точка синхронизации не является частью игры, можно спрятать
    работу за экраном загрузки или катсценой.

    * *Вычисления происходят незаметно для игрока.* В отличие от предыдущего варианта,
        можно придумать что-нибудь, чтобы
        отвлечь игрока, пока игра плотно занята своим делом.

    * *Тяжелее понять, когда именно будет произведена работа.* Это не совсем
        согласуется с предыдущим моментом. Даже если будет маленькая вероятность
        произвести необходимую работу, надо убедиться, что игра этим воспользуется.

        Но что *невозможно* предугадать, так это то, действительно ли игрок подойдет
        к точке синхронизации или выполнятся какие-либо другие условия, которые
        вы поставили. Если он потеряется в пространстве или игра зациклится,
        то вычисления будут отложены намного дольше, чем вы будете ожидать.

* **В фоне:**

    Обычно это означает, что стартует <span name="hysteresis">таймер</span>
    после первой модификации данных и в нем обрабатываются те изменения,
    которые произошли.

    <aside name="hysteresis">

    Для умышленной задержки между действиями пользователя и моментом получения
    результатов существует термин -- [*гистерезис*](http://ru.wikipedia.org/wiki/Гистерезис).

    </aside>

    * *Можно настроить частоту вызова таймера.* Меняя интервал таймера,
        можно быть уверенным, что работа производится так часто (или редко),
        как вы хотите.

    * *Делается больше ненужной работы.* Если меняется малая часть данных,
        то таймеру придется пропускать большие куски, прежде чем он доберется
        до реальной работы.

    * *Необходима поддержка асинхронности.*
        Обработка данных в фоне предполагает, что игрок имеет возможность
        продолжать играть, как будто ни в чем не бывало. Это значит,
        что нужно будет использовать треды или другой вариант одновременных
        вычислений, чтобы игра могла и дальше работать с данными, пока
        в нее играют.

        Поскольку игрок, вероятно, будет продолжать менять данные,
        которые вы обрабатываете в фоне, придется задуматься
        и о синхронизации доступа к данным.

### Какова область действия флага?

Представим нашу пиратскую игру, которая дает возможность игроку построить и улучшить
свой пиратский корабль. Корабли автоматически сохраняются онлайн, чтобы игрок имел
возможность продолжить игру с того места, где остановился в прошлый раз.
Мы используем грязный флаг для выяснения, какие палубы были обновлены,
чтобы послать изменения на сервер. Каждый блок данных, посылаемый на сервер,
содержит информацию о изменениях и немного метаданных, которые говорят о том,
в какой части корабля эти изменения произошли.

* **В случае узкой области:**

    Скажем, вы используете флаг для каждой доски на палубе.

    * *Будут обрабатываться только те данные, которые изменились.* Вы пошлете на сервер
        только те части корабля, которые были реально изменены игроком.

* **Если увеличить область:**

    Также можно использлвать флаг только для каждой палубы.
    Если на ней что-то изменились, мы помечаем <span name="swab">грязной</span> всю палубу.

    <aside name="swab">

    Тут можно было вставить плохую шутку про грязную палубу и швабру, но
    я воздержусь.

    </aside>

    * *В итоге будут посылаться не только измененные данные.* Добавьте одну маленькую бочку
        на палубу, и палуба целиком отправиться на сервер.

        * *Меньше памяти уйдет на флаги.* Добавьте десять бочек на палубу
          и вам нужен только один бит, чтобы отслеживать их всех.

    * *Меньше вспомогательной работы.* Когда обрабатываются измененные данные,
        всегда есть доля фиксированной работы, которую приходится делать, чтобы обработать
        поступившие изменения. В нашем примере, это может быть получение метаданных
        о месте, где произошли изменения. Чем больше область изменений,
        тем меньше апдейтов уйдет на сервер, таким образом экономится
        время на дополнительную работу.

## См. также

 * Этот паттерн широко используется в браузерных играх на клиентской стороне.
    Например, [Angular](http://angularjs.org/). Там используется грязный флаг, чтобы
    отследить данные, которые изменились на клиенте, и которые нужно отправить на сервер.

 * Физические движки так отличают объекты в движении и состоянии покоя.
    Поскольку статическое тело не двигается, пока на него не действуют другие силы,
    их не нужно постоянно просчитывать. Этот "я-двигаюсь" флаг является
    примером грязного флага, который указывает на то, были ли приложены
    к телу силы и нужно ли рассчитать их взаимодействия.
