^title Приспособленец
^section Пересмотренные паттерны проектирования

Поднимается туман, открывая взору старый величественный лес. Древние болиголовы
бесчисленным числом возвышаются над вами, образуя собор из зелени. Витражный
навес из листьев преломляет солнечный свет, превращая его в золотые лучи тумана.
Меж гигантских стволов можно разглядеть густой лес, простирающийся
вдаль.

О подобном другом мире мы мечтаем, будучи разработчиками игр, и
такие сцены часто возможны благодаря паттерну
со скромнейшим названием "Приспособленец" (Flyweight).

## Лес вместо деревьев

Я могу описать густой лес всего несколькими предложениями, но фактически
его *реализация* в игре в режиме реального времени -- совсем другая история. Когда целый
лес из отдельных деревьев заполняет экран, всё, что видит программист графики --
это миллионы полигонов, которые нужно как-то передавать видеокарте
каждую шестидесятую часть секунды.

Мы говорим о тысячах деревьев, каждое из которых имеет детализированную геометрию
из тысяч полигонов. Даже если у вас хватает *памяти*, чтобы описать этот лес,
чтобы отрендерить его, данные должны проделать путь по шине от центрального процессора
до видеокарты.

Каждое дерево имеет набор связанных с ним данных:

* Сетка из полигонов, которые определяют форму ствола, ветвей и зелени.
* Текстуры для коры и листьев.
* Его расположение и ориентация в лесу.
* Настраиваемые параметры, вроде размера и оттенка, чтобы каждое дерево выглядело разным.

Если бы пришлось набросать перечисленное в коде, вышло бы что-то вроде этого:

^code heavy-tree

Тут много данных, и особенно велики сетка и текстуры. Целый
лес данных объектов -- это слишком много, чтобы выбрасывать на центральный процессор за один кадр.
К счастью, есть проверенный временем трюк, позволяющий решить это проблему.

Ключевое наблюдение заключается в том, что хотя в лесу могут быть
тысячи деревьев, в основном все они выглядят похоже. Скорее всего, все они используют <span
name="same">одинаковую</span> сетку и текстуры. Это значит, что большинство полей в
данных объектах *одинаковы* во всех экземплярах.

<aside name="same">

Нужно быть сумасшедшим или миллиардером с соответствующим бюджетом для художников, чтобы
индивидуально моделировать каждое дерево в целом лесу.

</aside>

<span name="trees"></span>

<img src="images/flyweight-trees.png" alt="Ряд деревьев, каждое из которых имеет собственную сетку, кору, листья, параметры и положение."/>

<aside name="trees">

Обратите внимание, что написанное в маленьких прямоугольниках одинаково для каждого дерева.

</aside>

Можно смоделировать это явно, разбив объект наполовину. Сперва вытащим
данные, являющиеся <span name="type">общими</span> для всех деревьев и переместим их
в отдельный класс:

^code tree-model

Игре необходим только один из них, потому что нет причины помещать
одни и те же сетки и текстуры в память тысячу раз. Затем каждый *экземпляр*
дерева в мире получает *ссылку* на совместно используемый `TreeModel`. Что остается в
`Tree` -- состояние, уникальное для каждого экземпляра:

^code split-tree

Можно представить это так:

<img src="images/flyweight-tree-model.png" alt="Ряд деревьев, где каждое имеет собственные параметры и позицию, но указывает на совместно используемую модель с сеткой, корой и листьями."/>

<aside name="type">

Выглядит очень похоже на паттерн <a href="type-object.html" class="pattern">"Тип
объекта"</a>. Оба включают делегирование части состояния объекта некоему
другому объекту, совместно используемому несколькими экземплярами. Как бы то ни было, цели
паттернов различны.

Цель паттерна "Тип объекта" (Type Object) -- минимизировать количество
классов, требующих определения, путем проталкивания "типов" в собственную объектную модель. Любое совместное использование памяти, получаемое при этом,
всего лишь бонус. Паттерн "Приспособленец" (Flyweight) полностью нацелен на эффективность.

</aside>

Все это хорошо для хранения в основной памяти, но не
помогает при рендеринге. Перед тем как лес окажется на экране, ему нужно пройти путь до
центрального процессора. Мы должны выразить это совместное использование ресурсов способом,
понятным видеокарте.

## Тысяча экземпляров

Чтобы минимизировать количество данных, которые нужно протолкнуть к видеокарте, хочется иметь возможность
отослать совместно используемые данные -- `TreeModel` -- только *однажды*. Затем отдельно
проталкиваем уникальные данные каждого экземпляра дерева -- его позицию, цвет и масштаб.
Наконец, говорим видеокарте: "Используй ту модель, чтобы отрендерить каждый из этих
экземпляров."

К счастью, сегодняшние графические API и <span name="hardware">карты</span>
поддерживают именно это. Подробности утомительны и выходят за рамки данной книги,
но как Direct3D, так и OpenGL могут осуществлять нечто, называемое [*рендерингом
инстансингом*](http://ru.wikipedia.org/wiki/Geometry_Instancing).

В обоих API вы предоставляете два потока данных. Первый является двоичным объектом общих
данных, которые будут рендериться несколько раз -- сетка и текстуры в нашем
"древесном" примере. Второй -- это список экземпляров и их параметров, которые
будут использоваться для того, чтобы разнообразить первый кусок данных каждый раз при отрисовке. С помощью
единственного вызова метода отрисовки появляется целый лес.

<aside name="hardware">

Тот факт, что это API реализуется напрямую графической картой, означает, что
паттерн "Приспособленец", может быть, единственный паттерн проектирования "Банды четырех", имеющий реальную
аппаратную поддержку.

</aside>

## Паттерн "Приспособленец"

Теперь, когда в нашем запасе есть один конкретный пример, я могу провести вас
в целом по паттерну. "Приспособленец" ("Flyweight" по англ. -- игра слов "fly" -- лететь, "weight" -- вес) вступает в игру, когда есть
объекты, требующие большей "легковесности", как правило, потому что их слишком
много.

При рендеринге инстансингом они не столько едят память,
сколько отнимают *время* на проталкивание каждого отдельного дерева по шине к
видеокарте, но основная идея остается той же.

Паттерн решает это, разделяя данные объекта на два вида.
Первый вид данных -- это не уникальные для отдельного *экземпляра*
данного объекта вещи, которые могут совместно использоваться всеми экземплярами. "Банда четырех" называет их
*внутренним* состоянием, но мне нравится думать о них, как о "контекстно-свободных" вещах. В
приведенном примере, это геометрия и текстуры для дерева.

Остальные данные -- это *внешнее* состояние, вещи, уникальные для данного
экземпляра. В данном случае это позиция, масштаб и цвет каждого дерева. Прямо
как в куске кода из приведенного примера, данный паттерн экономит память, позволяя совместно использовать
одну копию внешнего состояния всюду, где появляется объект.

Исходя из ранее увиденного, это кажется обычным совместным использованием ресурсов
и вряд ли стоит того, чтобы называться паттерном. Отчасти так происходит потому, что в приведенном примере
мы могли бы создать совершенно отдельную *сущность* для совместно используемого состояния:
`TreeModel`.

Я нахожу этот паттерн менее очевидным (и поэтому, более хитрым) при использовании в случаях,
когда нет действительно хорошо определенной сущности для совместно используемого объекта. В таких
случаях кажется, что объект магическим образом находится в нескольких местах
одновременно. Позвольте продемонстрировать другой пример.

## Место, где пустить корни

Земля, на которой растут деревья, тоже должна быть представлена в нашей игре.
Там могут быть клочки травы, грязь, холмы, озера, реки и любой другой
ландшафт, который только можно придумать. Мы сделаем землю *тайловой*: поверхность
мира -- огромная сетка крошечных тайлов (плиток). Каждый тайл покрыт одним видом ландшафта.

Каждый тип ландшафта имеет некоторое количество свойств, влияющих на геймплей:

* Цена хода, определяющая, как быстро игроки могут передвигаться по нему.
* Флаг, является ли ландшафт водным, чтобы его можно было пересекать на лодках.
* Текстура, используемая для рендеринга.

Поскольку мы, разработчики игр, параноики по части эффективности, то никогда не будем
хранить все это состояние в <span name="learned">каждом</span> тайле в мире.
Вместо этого, общий подход -- использовать перечисление для типов ландшафта:

<aside name="learned">

В конце концов, мы уже усвоили урок с теми деревьями.

</aside>

^code terrain-enum

Далее, мир поддерживает огромную сетку этих тайлов:

<span name="grid"></span>

^code enum-world

<aside name="grid">

Здесь я использую вложенный массив для хранения двумерной сетки. Это эффективно в C/C++,
поскольку упакует все элементы вместе. В Java или других языках с автоматическим
управлением памятью такой подход даст массив строк, где каждый
элемент -- это *ссылка* на массив столбцов, что может быть не так дружественно для
памяти, как бы хотелось.

В любом случае, реальный код будет лучше, если скрыть эту деталь реализации
за симпатичной двумерной структурой данных. Я делаю это здесь, только чтобы сохранять вещи
простыми.

</aside>

Чтобы действительно получить полезные данные о тайле, делаем что-то вроде этого:

^code enum-data

Ну, вы поняли. Это работает, но я нахожу такое уродливым. Я думаю о цене хода и о
влажности, как о *данных* ландшафта, но здесь это встроено в код. Хуже того,
данные о единственном типе ландшафта размазаны по пачке методов. Было бы
действительно хорошо хранить все это инкапсулированным вместе. В конце концов, вот для чего
разработаны объекты.

Было бы здорово иметь реальный *класс* ландшафта, например:

<span name="const"></span>

^code terrain-class

<aside name="const">

Вы заметите, что все методы здесь `const`. Это не совпадение.
Поскольку один и тот же объект используется в нескольких контекстах, если нужно будет модифицировать его,
изменения появятся в нескольких местах одновременно.

Возможно, это не то, чего вы хотите. Совместное использование объектов для экономии памяти должно быть
оптимизацией, не влияющей на видимое поведение приложения. Из-за
этого объекты "приспособленца" почти всегда неизменяемые.

</aside>

Но мы не хотим оплачивать цену содержания экземпляра этого для каждого тайла в
мире. Если вы посмотрите на данный класс, то увидите, что на самом деле там нет
*ничего* определяющего, *где* расположен тайл. В терминах "приспособленца",
*все* состояние ландшафта "внутреннее" или "контекстно-свободное".

Принимая это во внимание, нет причины содержать более одной единицы каждого типа ландшафта. Каждый
тайл с травой на земле идентичен любому другому. Вместо того, чтобы иметь необходимость содержать
мир в виде сетки перечислений или объектов ландшафта, сделаем его сеткой *указателей* на
объекты `Terrain`:

^code world-terrain-pointers

Каждая плитка, использующая одинаковый ландшафт, будет указывать на один и тот же экземпляр ландшафта.

<img src="images/flyweight-tiles.png" alt="Ряд тайлов. Каждый тайл указывает на совместно используемый объект травы, реки или холма."/>

Поскольку экземпляры ландшафта используются в нескольких местах, временем их жизни стало
бы управлять немного сложнее, если бы мы выделяли под них память динамически.
Вместо этого просто будем хранить их прямо в мире:

^code world-terrain

Далее можно использовать это, чтобы нарисовать землю так:

<span name="generate"></span>

^code generate

<aside name="generate">

Признаюсь, это не величайший алгоритм процедурной генерации ландшафта
в мире.

</aside>

Теперь вместо методов к `World` для доступа к свойствам ландшафта можно
воздействовать на объект `Terrain` напрямую:

^code get-tile

Таким образом, `World` более не связан со всяческими деталями ландшафтов. Если
требуется какое-то свойство тайла, можно получить его прямо из объекта:

^code use-get-tile

Мы вернулись к приятному API работы с реальными объектами и сделали это
практически без дополнительных затрат ресурсов -- размер указателя часто не больше размера перечисления.

## Что насчёт производительности?

Я сказал здесь "практически", потому что дотошные борцы за производительность правомерно захотят
узнать, как это соотносится с использованием перечисления. Ссылка на ландшафт по указателю
предполагает косвенный поиск. Для получения каких-либо данных о ландшафте, например, цены хода,
сначала придется следовать по указателю на сетку, чтобы найти объект ландшафта, а
затем найти там цену хода. Такое следование по указателю может привести к <span
name="cache">промаху в кэше</span>, что может замедлить работу.

<aside name="cache">

Гораздо больше о следовании по указателю и промахах в кэше можно найти в главе о паттерне <a href
="data-locality.html" class="pattern">"Местоположение данных"</a>.

</aside>

Как всегда, золотое правило оптимизации -- *сначала профилируй*. Современное компьютерное
аппаратное обеспечение слишком комплексно, чтобы производительность оставалась игрой чистого разума. В
моих тестах для данной главы не было замечено потерь при использовании "приспособленца", а не
перечисления. На самом деле, "приспособленцы" были заметно быстрее. Но это полностью зависит
от того, как в памяти выстроились другие вещи.

В чем я *действительно* уверен, так это в том, что возможность использования объектов "приспособленца" не должна
с ходу отклоняться. Они дают преимущества объектно-ориентированного стиля без
издержек на тонны объектов. Если вы обнаружили, что создаете перечисление и делаете
множество переключателей в нем, лучше рассмотрите данный паттерн. Если волнуетесь о
производительности, по крайней мере, профилируйте перед тем, как привести код к менее
поддерживаемому стилю.

## См. также

 *  В примере с тайлами мы просто поспешно создали по экземпляру для каждого
    типа ландшафта и сохранили их в `World`. Это позволило легко находить и повторно использовать
    совместные экземпляры. Однако во многих случаях вы не захотите создавать *всех*
    "приспособленцев" сразу.

    Если невозможно предугадать, какие из них действительно понадобятся, лучше создавать
    их по требованию. Чтобы получить преимущество совместного использования, при запросе одного
    сначала убедитесь, не создали ли вы уже идентичный. Если так, просто верните
    тот экземпляр.

    Обычно это означает, что нужно инкапсулировать конструкцию за каким-то
    интерфейсом, который сначала может разыскать существующий объект. Скрытие конструктора
    подобным образом -- это пример паттерна <a
    href="http://ru.wikipedia.org/wiki/Фабричный_метод_(шаблон_проектирования)" class="gof-
    pattern">"Фабричный метод"</a>.

    Чтобы возвратить ранее созданного "приспособленца", нужно отслеживать
    пул уже созданных экземпляров. Как подразумевает название,
    это означает, что паттерн <a href="object-pool.html" class="pattern">"Объектный
    пул"</a> может быть полезным местом для их хранения.

 *  Когда вы используете паттерн <a class="pattern" href="state.html">"Состояние"</a>,
    у вас часто есть объекты "состояния", не имеющие никаких полей, уникальных для
    машины, в которой используется состояние. Сущность
    и методы состояния -- все, что нам пригодится. В таком случае можно применить
    данный паттерн и повторно использовать тот же экземпляр состояния в нескольких машинах состояний
    в одно и то же время без каких-либо проблем.
