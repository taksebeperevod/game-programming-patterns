^title Команда
^section Повторяем паттерны проектирования

Команда - один из моих любимых паттернов. В большинстве больших программ, которые я пишу, будь то игры или что-то другое, употребляется этот паттерн. При использовании в нужном месте он аккуратно распутывает действительно кривой код. Для такого раздутого паттерна у "Банды четырех" есть предсказуемо малопонятное определение:

> Инкапсулируйте запрос в качестве объекта, тем самым позволяя пользователям параметризовать клиентов с различными запросами, поставьте в очередь или запишите запросы в журнал и организуйте поддержку отменяемых операций.

Согласитесь, страшное предложение? Прежде всего, оно искажает все, что бы эта метафора ни пыталась заключить. Вне странного мира программного обеспечения, где слова могут означать всё, что угодно, "клиент" -- это человек, с которым ведут бизнес. Вплоть до настоящего времени людей нельзя было "параметризовать".

Далее, оставшаяся часть предложения - это просто список того, к чему, вероятно, можно применить данный паттерн. Не очень понятно, если вашего сценария использования нет в этом списке. *Мой* сжатый слоган для паттерна "Команда" будет звучать так:

**Команда - это *<span name="latin">материализованный</span> вызов метода*.**

<aside name="latin">

"Материализовать" ("reify") происходит от латинского "res" — "вещь", с добавлением английского суффикса "&ndash;fy". Поэтому это слово буквально значит "овеществлять" ("thingify"), что, честно говоря, гораздо больше подошло бы в качестве определения.

</aside>

Конечно, под словом "сжатый" часто подразумевается "предельно краткий", поэтому определение паттерна, вероятно, не очень улучшилось. Позвольте мне предложить немного более развернутое описание. "Материализовать" (если вы никогда не слышали этого слова) означает "сделать реальным". Другим термином для определения слова "материализовать" является сделать что-то объектом "первого класса".

<aside name="reflection">

*Системы рефлексии* в некоторых языках программирования позволяют работать с типами в программе императивно во время выполнения. Можно получить объект, представляющий класс другого объекта, и поиграть с ним, чтобы увидеть, что умеет делать тип. Другими словами, рефлексия - это *материализованная система типов*.

</aside>

Оба выражения подразумевают взятие некоего <span name="reflection">*концепта*</span> и превращение его в кусок *данных* -- объект -- который можно поместить в переменную, передать на вход функции и т.д. Таким образом, называя паттерн "Команда" "вызовом материализованного метода", я имею в виду, что это вызов метода, обернутый в объект.

Это во многом похоже на "функцию обратного вызова", "функцию первого класса", "указатель на функцию", "замыкание" или "частично применяемую функцию", в зависимости от того, на каком языке вы программируете, и, на самом деле, все это растения из одного сада. Далее "Банда четырёх" пишет:

> Команды - это объектно-ориентированная замена функций обратного вызова.

Это определение стало бы намного более удачным для паттерна, нежели то, которое они выбрали.

Но все это абстрактно и туманно. Я люблю начинать главы с конкретики, а в этот раз у меня это не получилось. Чтобы восполнить эту досадную оплошность, с текущего момента и дальше будут только сухие примеры, в которых команды найдут блестящее применение.

## Настройка ввода

В любой игре где-то есть кусок кода, который считывает необработанные данные пользователя с устройств ввода -- нажатия кнопок, клавиатурные события, щелчки мышью - что угодно. Он каждый раз берет входные данные и преобразует их в имеющее смысл действие в игре:

<img src="images/command-buttons-one.png" alt="Контроллер с кнопкой A, привязанной к swapWeapon(), B, привязанной к lurch(), X, привязанной к jump(), и Y, привязанной к fireGun()." />

Самая простая реализация выглядит примерно так:

<span name="lurch"></span>

^code handle-input

<aside name="lurch">

Профессиональный совет: не нажимайте "B" слишком часто.

</aside>

Эта функция обычно вызывается раз в кадр паттерном <a class="pattern" href="game-loop.html">"Игровой цикл"</a>, и я уверен, вы сможете понять, что она делает. Она работает, если мы хотим жестко привязать кнопки ввода к игровым действиям, но многие игры разрешают пользователям *настроить* привязку кнопок.

Чтобы поддерживать это, нужно поменять прямые вызовы `jump()` и `fireGun()` на что-то, что можно изменить. "Изменить" звучит во многом как определить переменную, поэтому нужен *объект*, который можно использовать для отображения игрового действия. Встречайте: паттерн "Команда".

Определим базовый класс, представляющий срабатываемую игровую команду:

<span name="one-method"></span>

^code command

<aside name="one-method">

Если есть интерфейс с единственным методом, который ничего не возвращает, очень вероятно, что это паттерн "Команда".

</aside>

Затем создаем подклассы для каждого из различных игровых действий:

^code command-classes

В обработчике входных данных сохраним указатель на команду для каждой кнопки:

^code input-handler-class

Теперь обработка входных данных просто делегирует полномочия:

<span name="null"></span>

^code handle-input-commands

<aside name="null">

Обратили внимание, что здесь мы не проверяем на равенство `null`? Следовательно, предполагается, что каждая кнопка будет иметь *некоторую* привязанную к ней команду.

Если мы хотим поддерживать бездействующие кнопки без необходимости явно проверять на равенство `null`, можно определить класс команды, чей метод `execute()` ничего не делает. Затем вместо того, чтобы установить обработчик кнопки в `null`, делаем его указателем на тот объект.
Это паттерн, называемый ["Нулевым объектом"](http://ru.wikipedia.org/wiki/Null_object_%28%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29).

</aside>

Там, где при вводе использовался прямой вызов функции, теперь появился слой абстракции:

<img src="images/command-buttons-two.png" alt="Контроллер, где каждая кнопка привязана к соответствующей переменной 'button_', которая в свою очередь привязана к функции." />

В этом суть паттерна "Команда". Если вы уже видите его преимущество, рассматривайте оставшуюся часть главы, как бонус.

## Директивы для акторов

Только что определенные классы команд приемлемы в предыдущем примере, но весьма ограничены. Проблема в том, что они предполагают существование высокоуровневых функций `jump()`, `fireGun()` и прочих, неявно знающих, как найти аватар игрока и заставить его танцевать, как марионетку, которой он и является.

Эта предполагаемая связь ограничивает пользу данных команд. *Единственный*, кто может подпрыгнуть по команде `JumpCommand` - это игрок. Давайте ослабим это ограничение. Вместо вызова функций, самостоятельно находящих объект команды, *передадим на вход* объект, которым хотим управлять:

^code actor-command

Здесь `GameActor` - класс "игрового объекта", представляющий персонажа в игровом мире. Передаем его в `execute()`, чтобы унаследованная команда могла вызвать методы, применяя их к выбранному актору, например:

^code jump-actor

Теперь можно использовать этот единственный класс, чтобы заставить прыгать любого персонажа в игре. Нам просто не хватает кусочка между обработчиком пользовательского ввода и командой, который бы принимал команду и вызывал её на правильном объекте. Сначала изменим `handleInput()` так, чтобы он *возвращал* команды:

^code handle-input-return

Он не может выполнить команду немедленно, потому что не знает, какого актора передать на вход. Вот где мы воспользуемся тем фактом, что команда является материализованным вызовом -- можно *отложить* выполнение вызова.

Далее нужен какой-то код, который берет команду и запускает на акторе, представляющем игрока. Что-то вроде этого:

^code call-actor-command

Предположим, что `actor` - это ссылка на персонаж игрока, тогда этот код правильно передвигает его согласно управляющим клавишам пользователя, поэтому мы возвращаемся к тому же поведению из первого примера. Но добавление уровня абстракции между командой и выполняющим ее актором дает небольшое изящное преимущество: *теперь можно позволить игроку управлять любым актором в игре, просто сменив актора, на котором выполняются команды.*

На практике это не распространенная возможность, но есть аналогичный сценарий использования, *действительно* часто всплывающий. До сих пор мы рассматривали только управляемого игроком персонажа, но что насчет других акторов в мире? Они управляются искусственным интеллектом игры. Можно использовать тот же самый паттерн "Команда" в качестве интерфейса между движком искусственного интеллекта и акторами: код искусственного интеллекта просто генерирует объекты `Command`.

Здесь декомпозиция искусственного интеллекта, выбирающего команды, и кода актора, выполняющего их, предоставляет хороший уровень гибкости. Можно использовать различные модули искусственного интеллекта для различных акторов. Или можно смешать и сопоставить куски искусственного интеллекта для различных видов поведения. Хотите получить более агрессивного врага? Просто подключите более агрессивный искусственный интеллект, чтобы генерировать команды для него. Фактически можно даже прицепить искусственный интеллект к персонажу *игрока*, что может быть полезно для таких вещей, как демо-режим, когда игра должна работать на автопилоте.

<span name="queue">Путем</span> превращения команд, управляющих актором, в объекты первого класса, мы убрали жесткую зависимость от прямого вызова метода. Вместо этого получилось что-то вроде очереди или потока команд:

<aside name="queue">

Намного больше о том, что может сделать постановка в очередь, вы найдете в главе <a href="event-queue.html" class="pattern">"Очередь событий"</a>.

</aside>

<span name="stream"></span>

<img src="images/command-stream.png" alt="Поток, соединяющий искусственный интеллект с актором." />

<aside name="stream">

Почему я чувствую потребность нарисовать для вас картинку "потока"? И почему он выглядит, как труба?

</aside>

Некоторый код (обработчик пользовательского ввода или искусственный интеллект) <span name="network">генерирует</span> команды и помещает их в поток. Другой код (диспетчер или сам актор) получает команды и вызывает их. Поместив очередь в центр, мы сделали декомпозицию генератора на одном конце от потребителя на другом.

<aside name="network">

Если взять эти команды и сделать их *сериализуемыми*, то можно послать поток из них по сети. Мы можем взять данные, введенные игроком, послать их по сети на другую машину и затем повторно воспроизвести их. Это важная часть создания сетевой многопользовательской игры.

</aside>

## Отмена и повтор

Последний пример - наиболее известное применение данного паттерна. Если объект команды может что-то *делать*, малый шаг отделяет его от возможности *отмены* своих действий. Отмена используется в некоторых стратегических играх, где можно откатить шаги, которые не понравились. Это *дань этикету* в инструментах, используемых для *создания* игр. <span name="hate">Самый надежный способ</span> заставить гейм-дизайнеров ненавидеть вас - дать им редактор уровней, который не может отменять ошибки, допущенные с помощью их толстых пальцев.

<aside name="hate">

Возможно, сейчас я рассуждаю, исходя из своего опыта.

</aside>

Без паттерна "Команда" реализация отмены действия на удивление сложна. С ним - это пара пустяков. Давайте предположим, что делаем однопользовательскую пошаговую игру и хотим разрешить пользователям отменять шаги, чтобы они могли больше сосредоточиться на стратегии и меньше на угадывании.

Мы уже используем удобные команды для абстрагирования обработки входных данных, поэтому каждый шаг, производимый игроком, инкапсулирован в них. Например, перемещение единицы техники может выглядеть так:

^code move-unit

Обратите внимание, что есть маленькое отличие от предыдущих команд. В последнем примере мы хотели *абстрагировать* команду от модифицированного ею актора. В данном случае мы специально хотим *привязать* ее к перемещаемой единице техники. Экземпляр данной команды не является обобщённой операцией вида "двигать что-то", которую можно использовать во многих ситуациях; это определенное конкретное перемещение в игровой последовательности шагов.

В этом разница в реализации паттерна "Команда". В некоторых случаях, например, в первой паре примеров, команда - это объект многократного использования, представляющий *что-то, что можно сделать*. Предыдущий обработчик входных данных закреплялся за единственным объектом команды и вызывал его метод `execute()` каждый раз, когда была нажата верная кнопка.

Здесь команды более специфичны. Они представляют что-то, что может быть сделано в определённый момент времени. Это означает, что код обработки входных данных будет <span name="free">*создавать*</span> экземпляр каждый раз, когда игрок выберет шаг. Что-то вроде этого:

^code get-move

<aside name="free">

Конечно, в языках без сборки мусора, например C++, это означает, что код, выполняющий команды, также будет отвечать за освобождение памяти из-под них.

</aside>

Факт того, что команды используются только один раз, за секунду станет нашим преимуществом. Для того чтобы сделать команды отменяемыми, определим другую операцию, которую потребуется реализовать каждому классу команды:

^code undo-command

Метод `undo()` возвращает игровое состояние, измененное соответствующим методом `execute()`. Вот предыдущая команда перемещения с поддержкой отмены:

^code undo-move-unit

Обратите внимание, что мы добавили к классу <span name="memento">больше состояний</span>. Когда единица техники перемещается, она забывает, где была ранее. Если мы хотим иметь возможность отменять перемещение, то должны сами запоминать предыдущую позицию единицы, что и делают `xBefore_` и `yBefore_`.

<aside name="memento">

Кажется, тут место для паттерна <a href="https://ru.wikipedia.org/wiki/%D0%A5%D1%80%D0%B0%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_%28%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29" class="gof-pattern">"Хранитель"</a>, но я не видел, чтобы он где-то хорошо справлялся с работой. Так как команды, как правило, изменяют небольшую часть состояния объекта, фиксация остальных его данных - потеря памяти. Выгоднее вручную хранить только изменяемые биты.

<a href="http://en.wikipedia.org/wiki/Persistent_data_structure">*Персистентные структуры данных*</a> являются альтернативой. С ними каждое изменение объекта возвращает новый объект, оставляя оригинал неизменным. Посредством умной реализации эти новые объекты используют данные совместно с предыдущими, поэтому это гораздо проще, чем клонирование целого объекта.

Используя персистентную структуру данных, каждая команда хранит ссылку на объект перед выполнением, а отмена просто является переключением обратно к старому объекту.

</aside>

Чтобы позволить игроку отменить шаг, придерживаем последнюю команду, которую он выполнил. Когда игрок ударяет по Control-Z, вызываем метод команды `undo()`. (Если игрок уже делал отмену, тогда метод превращается в "redo", и мы выполняем команду снова.)

Поддержка нескольких уровней отмены действия не намного сложнее. Вместо того, чтобы запомнить последнюю команду, храним список команд и ссылку на текущую команду. Когда игрок выполняет команду, помещаем ее в конец списка и ставим туда указатель "текущей" команды.

<img src="images/command-undo.png" alt="Стек команд от самой старой к самой новой. Стрелка 'текущая' указывает на команду, стрелка 'отмена' указывает на предыдущую команду, а 'повтор' указывает на следующую." />

Когда игрок выбирает "Отмену", отменяем текущую команду и перемещаем текущий указатель назад. Когда игрок выбирает <span name="replay">"Повтор"</span>, перемещаем указатель вперед, а затем выполняем эту команду. Если игрок выбирает новую команду после отмены какой-то, все в списке после текущей команды отбрасывается.

В первый раз после реализации этого в редакторе уровней я почувствовал себя волшебником. Я был поражен простотой реализации и тем, насколько хорошо все работало. Требуется дисциплина, чтобы увериться в том, что каждое изменение данных проходит сквозь команду, но как только вы это сделаете, остальное будет просто.

<aside name="replay">

Повтор, возможно, не так распространен в играх, но повторное *воспроизведение* - да. В ходе простейшей реализации мы бы записали состояние всей игры в каждом кадре, чтобы ее можно было повторно воспроизвести, но это бы потребовало слишком много памяти.

Вместо этого, многие игры записывают набор команд, выполняемых каждой сущностью каждый кадр. Для повторного воспроизведения движок просто запускает симуляцию обычной игры, выполняя предварительно записанные команды.

</aside>

## Классически и не функционально?

Ранее я говорил, что команды подобны функциям первого класса или замыканиям, но в каждом приведенном примере использовались определения классов. Если вы знакомы с функциональным программированием, то, возможно, заинтересуетесь - а где же функции?

Я писал примеры таким образом, поскольку C++ имеет весьма ограниченную поддержку функций первого класса. Указатели на функции не имеют состояний, функторы странные и все еще требуют определения класса, а с лямбда-выражениями в C++11 сложно работать из-за ручного управления памятью.

Я говорю это *не* к тому, что нельзя использовать функции для паттерна "Команда" в других языках. Если есть такая роскошь, как язык с реальными замыканиями, непременно используйте их! В <span name="some">некоторых</span> отношениях, паттерн "Команда" - это способ эмуляции замыканий в не поддерживающих их языках программирования.

<aside name="some">

Здесь я говорю "в *некоторых* отношениях", потому что построение реальных классов или структур для команд все еще полезно даже в языках, имеющих замыкания. Если команда имеет несколько операций (например, отменяемых команд), преобразование ее в единственную функцию неудобно.

Определение реального класса с полями также помогает читателям легко понять, какие данные содержит команда. Замыкания - это удивительно быстрый способ автоматического обертывания некоторого состояния, но они могут быть настолько автоматизированными, что сложно понять, какое состояние поддерживают на самом деле.

</aside>

Например, если бы мы писали игру на JavaScript, то могли создать команду перемещения единицы техники просто так:

    :::javascript
    function makeMoveUnitCommand(unit, x, y) {
      // Эта функция здесь - объект команды:
      return function() {
        unit.moveTo(x, y);
      }
    }

Можно также добавить поддержку отмены, используя пару замыканий:

    :::javascript
    function makeMoveUnitCommand(unit, x, y) {
      var xBefore, yBefore;
      return {
        execute: function() {
          xBefore = unit.x();
          yBefore = unit.y();
          unit.moveTo(x, y);
        },
        undo: function() {
          unit.moveTo(xBefore, yBefore);
        }
      };
    }

Если вам удобно использовать функциональный стиль, то данный способ будет естественным. Если же нет, я надеюсь, что данная глава немного помогла вам на этом пути. По моему мнению, польза от паттерна "Команда" действительно показывает, насколько эффективна функциональная парадигма для многих задач.

## См. также

 *  В конечном итоге, можно прийти к большому количеству различных классов команд. Для того, чтобы облегчить их реализацию, часто полезно определить конкретный базовый класс с набором удобных высокоуровневых методов, которые производные команды могут компоновать, чтобы определить свое поведение. Это превращает главный метод команды `execute()` в паттерн <a href="subclass-sandbox.html" class="pattern">"Подкласс песочница"</a>.

 *  В примерах был явный выбор актора для обработки команды. В некоторых случаях, особенно когда модель объекта иерархическая, это может быть не так очевидно. Объект может сам ответить на команду или решить делегировать ее какому-нибудь подчиненному объекту. Если сделаете так, то откроете для себя паттерн <a class="gof-pattern" href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B0_%D0%BE%D0%B1%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9">"Цепочка обязанностей"</a>.

 *  Некоторые команды - куски чистого поведения без состояний, например, `JumpCommand` в первом примере. В таких случаях поддержка <span name="singleton">более</span> одного экземпляра класса приведет к лишним потерям памяти, так как все экземпляры эквивалентны. С этим справляется паттерн <a class="gof-pattern" href="flyweight.html">"Приспособленец"</a>.

<aside name="singleton">

Также можно было бы сделать его паттерном <a href="singleton.html" class="gof-pattern">"Одиночкой"</a>, но друзья не позволяют друзьям создавать одиночек.

</aside>
